<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://lumagi.github.io/</id><title>RAndom Notes on Tech</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2025-12-29T15:14:56+01:00</updated> <author> <name>Lukas Magel</name> <uri>https://lumagi.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://lumagi.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://lumagi.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2025 Lukas Magel </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Decoding raw i.MX6 NAND flash images</title><link href="https://lumagi.github.io/posts/imx6-nand-flash/" rel="alternate" type="text/html" title="Decoding raw i.MX6 NAND flash images" /><published>2025-10-26T18:21:00+01:00</published> <updated>2025-12-28T19:20:38+01:00</updated> <id>https://lumagi.github.io/posts/imx6-nand-flash/</id> <content src="https://lumagi.github.io/posts/imx6-nand-flash/" /> <author> <name>Lukas Magel</name> </author> <category term="Embedded" /> <summary> I was recently working with a PCB featuring an i.MX6 SoC and a raw NAND flash chip. The SoC was running a u-boot and an embedded Linux off of the NAND flash chip. Since the debug port was properly locked, I wanted to take a look at the embedded u-boot and Linux. I decided to desolder and dump the flash chip. This post documents how the i.MX6 stores user data on an external NAND flash and how th... </summary> </entry> <entry><title>PCAN Device ID Support in Linux Kernel</title><link href="https://lumagi.github.io/posts/Device-ID-support-in-Linux/" rel="alternate" type="text/html" title="PCAN Device ID Support in Linux Kernel" /><published>2023-08-14T12:08:00+02:00</published> <updated>2023-10-04T16:35:28+02:00</updated> <id>https://lumagi.github.io/posts/Device-ID-support-in-Linux/</id> <content src="https://lumagi.github.io/posts/Device-ID-support-in-Linux/" /> <author> <name>Lukas Magel</name> </author> <category term="Linux" /> <summary> When building a test setup with multiple CAN controllers, it is crucial to ensure persistent device names, no matter boot or enumeration order. The PCAN USB-FD devices by Peak do not export a USB serial number, making it difficult to write udev rules to match against them. Instead, the controllers provide a concept called a Device ID. This ID is a 32 bit integer that is stored in the device’s f... </summary> </entry> <entry><title>Determining ARM firmware base addresses</title><link href="https://lumagi.github.io/posts/finding-arm-firmware-base-with-literal-pools/" rel="alternate" type="text/html" title="Determining ARM firmware base addresses" /><published>2022-04-15T20:08:00+02:00</published> <updated>2022-09-30T08:26:34+02:00</updated> <id>https://lumagi.github.io/posts/finding-arm-firmware-base-with-literal-pools/</id> <content src="https://lumagi.github.io/posts/finding-arm-firmware-base-with-literal-pools/" /> <author> <name>Lukas Magel</name> </author> <category term="firmware" /> <summary> A common problem when reversing a firmware blob is to determine the correct offset at which to place the firmware file in memory. Recently, while doing some research into possible solutions, I came across a paper by Zhu et al. The paper proposes an approach that exploits the addresses found in 32bit ARM literal pools to determine the correct firmware offset. I was able to successfully implement... </summary> </entry> <entry><title>Debugging Linux Module Loading with QEMU</title><link href="https://lumagi.github.io/posts/compiling-intree-linux-modules/" rel="alternate" type="text/html" title="Debugging Linux Module Loading with QEMU" /><published>2021-12-11T18:21:11+01:00</published> <updated>2022-04-15T19:40:53+02:00</updated> <id>https://lumagi.github.io/posts/compiling-intree-linux-modules/</id> <content src="https://lumagi.github.io/posts/compiling-intree-linux-modules/" /> <author> <name>Lukas Magel</name> </author> <category term="Linux" /> <category term="Kernel" /> <summary> My company uses the ETAS ES582.1 CAN adapters to interface with a CAN bus. Since recently, the kernel has mainline support for these devices (the etas_es58x driver). However, my work operating system of choice, Kali Linux, does not ship with a prebuilt kernel module for the devices out of the box. Hence, I needed to manually compile the module to use the devices under Kali. While doing so, I ... </summary> </entry> </feed>
