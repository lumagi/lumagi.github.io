<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Debugging Linux Module Loading with QEMU" /><meta property="og:locale" content="en" /><meta name="description" content="My company uses the ETAS ES582.1 CAN adapters to interface with a CAN bus. Since recently, the kernel has mainline support for these devices (the etas_es58x driver). However, my work operating system of choice, Kali Linux, does not ship with a prebuilt kernel module for the devices out of the box. Hence, I needed to manually compile the module to use the devices under Kali. While doing so, I ran into binary compatibility issues and ended up debugging the module loading process with QEMU to determine the root cause. This blog post is a summary of the process. I first explain the QEMU VM installation process, explain the issues I encountered, and outline the debugging process to pinpoint the issue. Spoiler: If you arrived at this post in hopes of fixing the error message below, try installing the pahole tool. On Kali, the required package is called dwarves. If that doesn’t work, I invite you to follow this post and try debugging for yourself. On the host, I used an Arch Linux installation. The QEMU VM ran the target operating system, a Kali Linux installation. All my attempts were made on Kernel version 5.14.16. QEMU VM Setup On Arch, I merely needed to install the qemu package to get started. I then set up the VM image and started the installation. For the image, I intentionally used the raw format because it can easily be mounted on the host side as a loop device for manipulation. Additionally, for filesystems like ext4 that support holes, only non-zero blocks in the file will take up disk space. I created a rather big image to accommodate the source code and debug package. The second command starts up the VM with KVM, 4GB of memory and inserts the Kali installation disk. 1 2 $ qemu-img create -f raw kali_hd2.raw 16G $ qemu-system-x86_64 -boot order=d -drive file=kali_hd.raw,format=raw -m 4G -enable-kvm -cdrom kali-linux-2021.3a-installer-netinst-amd64.iso I installed a minimal Kali version without desktop environment and no preinstalled pentesting tools to reduce the size. Next, I ran the VM without ISO and with enabled gdb stub for attaching the debugger later on: 1 $ qemu-system-x86_64 -boot order=d -drive file=kali_hd.raw,format=raw -m 4G -enable-kvm -s Kernel Module Compilation The next step was to actually compile the module inside the VM. I used the linux-source package for maximum compatibility with the prebuilt kernel. apt automatically pulled in Kali package version 5.14.16-1kali1. 1 2 3 4 $ sudo apt-get install build-essential libncurses5-dev libelf-dev libssl-dev $ sudo apt-get install linux-source linux-headers-amd64 $ tar -xf /usr/src/linux-source-5.14.tar.xz $ cd linux-source-5.14/ Next, I prepared the sources for compilation. I copied the configuration file and module symbol version file from the linux-headers package. 1 2 $ cp /usr/src/linux-headers-5.14.0-kali4-amd64/.config . $ cp /usr/src/linux-headers-5.14.0-kali4-amd64/Module.symvers . Since the module I wanted to compile was not enabled in the .config file, I manually enabled the module by adding the following line to the file: 1 CONFIG_CAN_ETAS_ES58X=m Finally, I was able to compile the module. The first step in the series of commands checks the configuration file for completeness and queries the user for any missing configuration option. I stuck with the defaults. 1 2 3 4 $ make oldconfig $ make prepare $ make modules_prepare $ make M=drivers/net/can/usb/etas_es58x/ Next I tried to insmod the new module and its dependencies for a quick test: 1 2 3 $ for i in can-dev usbcore crc16; do sudo modprobe $i; done $ sudo insmod drivers/net/can/usb/etas_es58x/etas_es58x.ko insmod: ERROR: could not insert module drivers/net/can/usb/etas_es58x/etas_es58x.ko: Invalid module format As expected, the module insertion failed due to some unknown issue with the module. Next, I checked the kernel log: 1 2 $ sudo dmesg | tail -n 1 [ 2056.862808] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 00000000909cc68f, val ffffffffc087f984 The debug message was rather cryptic, but revealed that there seemed to be some issue with the symbol relocation during module linking. I dug up the kernel code responsible for loading the modules and took a closer look at the loading process. Static analysis of the module loading process From the debug message, I was able to trace the location in the code where the linking process failed. The message was printed from inside __apply_relocate_add in arch/x86/kernel/module.c. The function is responsible for applying relocations to ELF sections of the module. A short excursion on relocations In generic terms, a relocation links the reference of a symbol to its definition. As an example, if a kernel module wants to call a function like printk, which it does not provide itself, it must know the address at which the function is located. Since the address is not known at compile time, it must be dynamically inserted into the module at load time. The process of performing this search and replace is defined by a relocation. The relocations that need to be applied to the kernel module at startup are stored in the ELF file along with code and data. For each section to which relocations must be applied, the module contains a .rela section with relocations. As an example, most modules feature a .text section that contains the compiled code of the module. The relocations for that section are stored in the .rela.text section. Each relocation in a .rela section consists of several values: The location relative to the start of the target section at which the relocation must be applied. A link to the symbol that must be inserted at the specified location. The type of the relocation. Relocation types are specific to a processor and define how the symbol value must be inserted at the location. An addend, however this is not strictly relevant to this post To give a quick example, below I list a relocation from the .rela.text section in the etas_es58x module: 1 2 Offset Info Type Sym. Value Sym. Name + Addend 000000000031 00c900000004 R_X86_64_PLT32 0000000000000000 memcpy - 4 The relocation specifies that the address of symbol memcpy must be placed at offset 0x31 relative to the beginning of the .text section. Analysis of the relocation error Below is the source code of __apply_relocate_add (arch/x86/kernel/module.c). The function applies all relocations contained in a single .rela section. For each relocation, it calculates the absolute address of the relocation in loc and the symbol value in val. The switch case statement that follows is responsible for applying the symbol value according to the relocation type. The function also performs a sanity check before it applies a relocation: it checks if the location in memory is properly initialized to zero. If not, it aborts with an error message. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 static int __apply_relocate_add(Elf64_Shdr *sechdrs, const char *strtab, unsigned int symindex, unsigned int relsec, struct module *me, void *(*write)(void *dest, const void *src, size_t len)) { unsigned int i; Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr; Elf64_Sym *sym; void *loc; u64 val; DEBUGP(&quot;Applying relocate section %u to %u\n&quot;, relsec, sechdrs[relsec].sh_info); for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) { /* This is where to make the change */ loc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset; /* This is the symbol it is referring to. Note that all undefined symbols have been resolved. */ sym = (Elf64_Sym *)sechdrs[symindex].sh_addr + ELF64_R_SYM(rel[i].r_info); DEBUGP(&quot;type %d st_value %Lx r_addend %Lx loc %Lx\n&quot;, (int)ELF64_R_TYPE(rel[i].r_info), sym-&gt;st_value, rel[i].r_addend, (u64)loc); val = sym-&gt;st_value + rel[i].r_addend; switch (ELF64_R_TYPE(rel[i].r_info)) { case R_X86_64_NONE: break; case R_X86_64_64: if (*(u64 *)loc != 0) goto invalid_relocation; write(loc, &amp;val, 8); break; case R_X86_64_32: if (*(u32 *)loc != 0) goto invalid_relocation; write(loc, &amp;val, 4); if (val != *(u32 *)loc) goto overflow; break; case R_X86_64_32S: if (*(s32 *)loc != 0) goto invalid_relocation; write(loc, &amp;val, 4); if ((s64)val != *(s32 *)loc) goto overflow; break; case R_X86_64_PC32: case R_X86_64_PLT32: if (*(u32 *)loc != 0) goto invalid_relocation; val -= (u64)loc; write(loc, &amp;val, 4); #if 0 if ((s64)val != *(s32 *)loc) goto overflow; #endif break; case R_X86_64_PC64: if (*(u64 *)loc != 0) goto invalid_relocation; val -= (u64)loc; write(loc, &amp;val, 8); break; default: pr_err(&quot;%s: Unknown rela relocation: %llu\n&quot;, me-&gt;name, ELF64_R_TYPE(rel[i].r_info)); return -ENOEXEC; } } return 0; invalid_relocation: pr_err(&quot;x86/modules: Skipping invalid relocation target, existing value is nonzero for type %d, loc %p, val %Lx\n&quot;, (int)ELF64_R_TYPE(rel[i].r_info), loc, val); return -ENOEXEC; overflow: pr_err(&quot;overflow in relocation type %d val %Lx\n&quot;, (int)ELF64_R_TYPE(rel[i].r_info), val); pr_err(&quot;`%s&#39; likely not compiled with -mcmodel=kernel\n&quot;, me-&gt;name); return -ENOEXEC; } This error message is the same as the one that was displayed when I tried to load my freshly-compiled module. Apparently, the dynamic linker encountered a relocation where the target address already held a non-zero value. However, a quick check with readelf -a etas_es58x.ko revealed that none of the relocation targets in the respective sections of the ELF file held a non-zero value. Consequently, the location had to have been manipulated at runtime while the module was being loaded. Unfortunately, the error message itself did not yield any useful information, like the section in which the issue occurred or the name of the affected symbol. Hence, I decided to investigate the issue further by debugging the function at runtime using QEMU. Dynamic analysis with QEMU and GDB In order to debug the kernel, I needed to set up gdb, acquire an ELF file of the compiled kernel that contained debug symbols, and disable KASLR, the kernel address space layout randomization. Setup I normally run gdb with gef which provides a convenient context print during debugging as well as some advanced features for memory inspection. Kali has a convenient package called linux-image-amd64-dbg. It contains an ELF file of the kernel with debugging symbols. However, for the debugging I needed both the source code as well as the ELF file on the host to connect to the gdb server stub of QEMU. Fortunately, with the raw image format, it was very easy to mount and copy data from the image: 1 2 3 4 5 6 7 8 $ sudo losetup -f kali_hd.raw $ sudo partprobe /dev/loop0 $ sudo mount /dev/loop0p1 /mnt $ cp -r /mnt/home/kali/linux-source-5.14/ . $ cd linux-source-5.14/ $ cp /mnt/usr/lib/debug/boot/vmlinux-5.14.0-kali4-amd64 . $ sudo umount /mnt $ sudo losetup -D I also loaded the ELF file of the kernel image into Ghidra for analysis. This allowed me to look around and do cross-referencing more easily than I was able to do from inside gdb. Lastly, I needed to disable the kernel address space layout randomization. This can be done by booting the kernel with the keyword nokaslr. I edited /etc/default/grub in the VM and added nokaslr to the following line in the file: 1 GRUB_CMDLINE_LINUX=&quot;nokaslr&quot; Then I recreated the grub configuration file: 1 $ sudo update-grub Breaking at the failing function I started the VM with the -s flag to start a gdb server on localhost:1234. Then I ran gdb and connected to the server: 1 $ gdb ./vmlinux-5.14.0-kali4-amd64 My plan was to pinpoint the relocation section and symbol that were causing the error condition by breaking at the error handler. However, due to compiler optimizations, most stack-based variable storage had been optimized away. The index of the relocation section relsec was passed into the function in the $ecx register but dropped after the absolute address of the section header had been calculated. Hence, I added two breakpoints in __apply_relocate_add. I added one breakpoint at the function start and another breakpoint at the error handler (the exact address of which I was able to determine with Ghidra). This setup allowed me to break at the function prologue to intercept the call parameters. If the second breakpoint hit right afterwards I knew that the last seen section was the offending one. 1 2 3 4 target remote localhost:1234 break apply_relocate_add break *(apply_relocate_add+0x85a08c) continue The offending module relocation I loaded the module inside the VM to trigger the breakpoint. At iteration relsec == 0x23, the second breakpoint hit, meaning that the error occurred there. The relocation section with index 0x23 was .rela.gnu.linkonce.this_module. The section contains the module struct with information (such as the name) about the module. The struct is kept in memory by the kernel and filled with runtime information. The relocation section for it featured two entries: 1 2 3 Offset Info Type Sym. Value Sym. Name + Addend 000000000138 00d400000001 R_X86_64_64 0000000000000000 init_module + 0 000000000340 00c800000001 R_X86_64_64 0000000000000000 cleanup_module + 0 The relocations tell the kernel to place the address of the init_module and the cleanup_module function at the specified offsets in the struct. One of the two relocations failed, however I didn’t yet know which one of the two. Fortunately, according to the decompiled source and assembly from Ghidra, the counter variable i in __apply_relocate_add had been placed in register r13 by the compiler, and the register was not written to for any other purpuses except the counter. This allowed me to simply dump the contents with p $r13 when the debugger hit the second breakpoint. The issue was with the second relocation for cleanup_module at index i == 1. Tracing struct module write accesses The next thing I wanted to try out was to determine what data was being written to the location. Since the offset was initialized to zero in the ELF file, it must have been written to directly before the relocation. I noticed that the module struct was first accessed quite early in the module loading process in setup_load_info of module.c: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static int setup_load_info(struct load_info *info, int flags) { ... info-&gt;index.mod = find_sec(info, &quot;.gnu.linkonce.this_module&quot;); if (!info-&gt;index.mod) { pr_warn(&quot;%s: No module found in object\n&quot;, info-&gt;name ?: &quot;(missing .modinfo section or name field)&quot;); return -ENOEXEC; } /* This is temporary: point mod into copy of data. */ info-&gt;mod = (void *)info-&gt;hdr + info-&gt;sechdrs[info-&gt;index.mod].sh_offset; ... } In the last line, info-&gt;mod is set to point to the location of the gnu.linkonce.this_module section. Successive access to the struct always uses the reference stored in info. As the comment explains, the address is only temporary since the module still has to be copied to its final location. In order to determine the address of section gnu.linkonce.this_module and hence the address of the module struct, I set a breakpoint in load_module because setup_load_info had been optimized away. 1 b *(load_module + 0x32d) Once the breakpoint hit, I set a custom watch point to break whenever the pointer to the cleanup_module function was being manipulated: 1 2 3 4 5 $ p $r13 $5 = 0xffffc90002e52c80 $ awatch *(0xffffc90002e52c80 + 0x340) Hardware access (read/write) watchpoint 2: *(0xffffc90002e52c80 + 0x340) $ continue The first time the breakpoint hit was in memcpy when the entire section was being copied to its final location in kernel memory. I added a new watchpoint to the same section offset in target memory. The new breakpoint hit in load_module+0x1025, which Ghidra presented as the following decompiled C code: 1 2 3 4 5 6 7 8 *(int **)(piVar37 + 0xce) = piVar37 + 0xcc; *(int **)(piVar37 + 0xcc) = piVar37 + 0xcc; *(int **)(piVar37 + 0xd0) = piVar37 + 0xd0; *(int **)(piVar37 + 0xd2) = piVar37 + 0xd0; LOCK(); piVar37[0xd6] = piVar37[0xd6] + 1; __mutex_init(piVar37 + 0x3a,s_&amp;mod-&gt;param_lock_ffffffff8210fe43, &amp;__key.7); uVar11 = find_sec(info,s___param_ffffffff8210fe54); The code writes some unknown data to the pointer of cleanup_module. Directly afterwards, it initializes a mutex and calls the find_sec function to determine the index of the __param section. There was only one location in the module loading code where this disassembly could have originated from - somewhat in the middle of the load_module code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* To avoid stressing percpu allocator, do this once we&#39;re unique. */ err = percpu_modalloc(mod, info); if (err) goto unlink_mod; /* Now module is in final location, initialize linked lists, etc. */ err = module_unload_init(mod); if (err) goto unlink_mod; init_param_lock(mod); /* * Now we&#39;ve got everything in the final locations, we can * find optional sections. */ err = find_module_sections(mod, info); if (err) goto free_unload; The mutex is initialized in init_param_lock and find_sec(&quot;__param&quot;) is executed in find_module_sections. Hence, the modification of the cleanup_module pointer had to occur in the module_unload_init function. And indeed, the function initialized two linked lists in struct module: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* Init the unload section of the module. */ static int module_unload_init(struct module *mod) { /* * Initialize reference counter to MODULE_REF_BASE. * refcnt == 0 means module is going. */ atomic_set(&amp;mod-&gt;refcnt, MODULE_REF_BASE); INIT_LIST_HEAD(&amp;mod-&gt;source_list); INIT_LIST_HEAD(&amp;mod-&gt;target_list); /* Hold reference count during initialization. */ atomic_inc(&amp;mod-&gt;refcnt); return 0; } In assembly, the initialization operation is even more clearly visible. 1 2 3 4 5 6 7 fff811405d7 LEA RAX,[R13 + 0x330] fff811405de MOV dword ptr [R13 + 0x358],0x1 fff811405e9 MOV qword ptr [R13 + 0x338],RAX fff811405f0 MOV qword ptr [R13 + 0x330],RAX fff811405f7 LEA RAX,[R13 + 0x340] fff811405fe MOV qword ptr [R13 + 0x340],RAX fff81140605 MOV qword ptr [R13 + 0x348],RAX Register $r13 contained the address of the module struct. The forward and backward pointers in each list were initialized to loop back to the list instance. Interestingly, the second of the two lists was clearly leaking into the cleanup_module pointer, which the relocation operation expected to be located at offset 0x340 of the struct. In the struct definition, the two linked lists were directly bordering on the cleanup_module function pointer, here called exit: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct module { // ... #ifdef CONFIG_MODULE_UNLOAD /* What modules depend on me? */ struct list_head source_list; /* What modules do I depend on? */ struct list_head target_list; /* Destruction function. */ void (*exit)(void); atomic_t refcnt; #endif // ... } To summarize the finding, the kernel module loading code and the relocations in the module were using two different, binary incompatible definitions of struct module. In the version known to the module, the exit function pointer had moved to the front of the struct by 16 Bytes. The root cause Although I had made an exact copy of the kernel configuration used by the Kali package maintainers, apparently some configuration options were manipulating the struct module definition and causing the offset. I made a diff of my local .config file and the one that shipped with the source package: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 CONFIG_DEBUG_KERNEL=y --- /usr/src/linux-headers-5.14.0-kali4-amd64/.config 2021-11-05 11:54:48.000000000 +0100 +++ .config 2021-11-22 21:41:25.519431077 +0100 @@ -2,9 +2,9 @@ # Automatically generated file; DO NOT EDIT. # Linux/x86 5.14.16 Kernel Configuration # -CONFIG_CC_VERSION_TEXT=&quot;gcc-10 (Debian 10.3.0-12) 10.3.0&quot; +CONFIG_CC_VERSION_TEXT=&quot;gcc (Debian 11.2.0-10) 11.2.0&quot; CONFIG_CC_IS_GCC=y -CONFIG_GCC_VERSION=100300 +CONFIG_GCC_VERSION=110200 CONFIG_CLANG_VERSION=0 CONFIG_AS_IS_GNU=y CONFIG_AS_VERSION=23700 @@ -14,6 +14,7 @@ CONFIG_CC_CAN_LINK=y CONFIG_CC_CAN_LINK_STATIC=y CONFIG_CC_HAS_ASM_GOTO=y +CONFIG_CC_HAS_ASM_GOTO_OUTPUT=y CONFIG_CC_HAS_ASM_INLINE=y CONFIG_CC_HAS_NO_PROFILE_FN_ATTR=y CONFIG_IRQ_WORK=y @@ -1893,7 +1894,7 @@ CONFIG_CAN_8DEV_USB=m CONFIG_CAN_EMS_USB=m CONFIG_CAN_ESD_USB2=m -# CONFIG_CAN_ETAS_ES58X is not set +CONFIG_CAN_ETAS_ES58X=m CONFIG_CAN_GS_USB=m CONFIG_CAN_KVASER_USB=m CONFIG_CAN_MCBA_USB=m @@ -9716,8 +9717,6 @@ CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y # CONFIG_DEBUG_INFO_DWARF4 is not set CONFIG_DEBUG_INFO_BTF=y -CONFIG_PAHOLE_HAS_SPLIT_BTF=y -CONFIG_DEBUG_INFO_BTF_MODULES=y # CONFIG_GDB_SCRIPTS is not set CONFIG_FRAME_WARN=2048 CONFIG_STRIP_ASM_SYMS=y @@ -9747,6 +9746,8 @@ CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL=y # CONFIG_UBSAN is not set CONFIG_HAVE_ARCH_KCSAN=y +CONFIG_HAVE_KCSAN_COMPILER=y +# CONFIG_KCSAN is not set # end of Generic Kernel Debugging Instruments CONFIG_DEBUG_KERNEL=y Of all configuration options that were different in both versions, option CONFIG_DEBUG_INFO_BTF_MODULES was the most interesting to my case. If enabled, it added two members to struct module: 1 2 3 4 5 6 7 8 struct module { // ... #ifdef CONFIG_DEBUG_INFO_BTF_MODULES unsigned int btf_data_size; void *btf_data; #endif // ... } Given the alignment requirements of amd64, the compiler would likely add 4 Byte of padding between the int and the void pointer, resulting in a size of 16 Byte for the two members. At that point I was fairly certain I had found the culprit for my issues. The only thing I did not know was why the option had been disabled. I retraced my compilation steps to determine why the option was disabled. The option seemed to be magically turned off after executing make oldconfig. After digging a little in the documentation, I found the reason: I was missing the pahole tool in my PATH. The Makefile automatically disabled the option if pahole was not found. I installed the dwarves package in Kali, recompiled the kernel module, and called insmod to insert the module into the kernel. And behold: 1 2 3 4 5 $ lsmod | grep etas etas_es58x 53248 0 usbcore 331776 1 etas_es58x can_dev 40960 1 etas_es58x crc16 16384 2 etas_es58x,ext4 The module was happy and alive. Takeaway Message When compiling a kernel module: always make sure that the configuration file doesn’t change while you’re not looking. This scenario wasn’t something I was aware of until now. And frankly, I do not consider it to be good design. Of course I don’t have the entire picture, but I believe a missing dependency should cause a build to fail fast, not produce incompatible artifacts." /><meta property="og:description" content="My company uses the ETAS ES582.1 CAN adapters to interface with a CAN bus. Since recently, the kernel has mainline support for these devices (the etas_es58x driver). However, my work operating system of choice, Kali Linux, does not ship with a prebuilt kernel module for the devices out of the box. Hence, I needed to manually compile the module to use the devices under Kali. While doing so, I ran into binary compatibility issues and ended up debugging the module loading process with QEMU to determine the root cause. This blog post is a summary of the process. I first explain the QEMU VM installation process, explain the issues I encountered, and outline the debugging process to pinpoint the issue. Spoiler: If you arrived at this post in hopes of fixing the error message below, try installing the pahole tool. On Kali, the required package is called dwarves. If that doesn’t work, I invite you to follow this post and try debugging for yourself. On the host, I used an Arch Linux installation. The QEMU VM ran the target operating system, a Kali Linux installation. All my attempts were made on Kernel version 5.14.16. QEMU VM Setup On Arch, I merely needed to install the qemu package to get started. I then set up the VM image and started the installation. For the image, I intentionally used the raw format because it can easily be mounted on the host side as a loop device for manipulation. Additionally, for filesystems like ext4 that support holes, only non-zero blocks in the file will take up disk space. I created a rather big image to accommodate the source code and debug package. The second command starts up the VM with KVM, 4GB of memory and inserts the Kali installation disk. 1 2 $ qemu-img create -f raw kali_hd2.raw 16G $ qemu-system-x86_64 -boot order=d -drive file=kali_hd.raw,format=raw -m 4G -enable-kvm -cdrom kali-linux-2021.3a-installer-netinst-amd64.iso I installed a minimal Kali version without desktop environment and no preinstalled pentesting tools to reduce the size. Next, I ran the VM without ISO and with enabled gdb stub for attaching the debugger later on: 1 $ qemu-system-x86_64 -boot order=d -drive file=kali_hd.raw,format=raw -m 4G -enable-kvm -s Kernel Module Compilation The next step was to actually compile the module inside the VM. I used the linux-source package for maximum compatibility with the prebuilt kernel. apt automatically pulled in Kali package version 5.14.16-1kali1. 1 2 3 4 $ sudo apt-get install build-essential libncurses5-dev libelf-dev libssl-dev $ sudo apt-get install linux-source linux-headers-amd64 $ tar -xf /usr/src/linux-source-5.14.tar.xz $ cd linux-source-5.14/ Next, I prepared the sources for compilation. I copied the configuration file and module symbol version file from the linux-headers package. 1 2 $ cp /usr/src/linux-headers-5.14.0-kali4-amd64/.config . $ cp /usr/src/linux-headers-5.14.0-kali4-amd64/Module.symvers . Since the module I wanted to compile was not enabled in the .config file, I manually enabled the module by adding the following line to the file: 1 CONFIG_CAN_ETAS_ES58X=m Finally, I was able to compile the module. The first step in the series of commands checks the configuration file for completeness and queries the user for any missing configuration option. I stuck with the defaults. 1 2 3 4 $ make oldconfig $ make prepare $ make modules_prepare $ make M=drivers/net/can/usb/etas_es58x/ Next I tried to insmod the new module and its dependencies for a quick test: 1 2 3 $ for i in can-dev usbcore crc16; do sudo modprobe $i; done $ sudo insmod drivers/net/can/usb/etas_es58x/etas_es58x.ko insmod: ERROR: could not insert module drivers/net/can/usb/etas_es58x/etas_es58x.ko: Invalid module format As expected, the module insertion failed due to some unknown issue with the module. Next, I checked the kernel log: 1 2 $ sudo dmesg | tail -n 1 [ 2056.862808] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 00000000909cc68f, val ffffffffc087f984 The debug message was rather cryptic, but revealed that there seemed to be some issue with the symbol relocation during module linking. I dug up the kernel code responsible for loading the modules and took a closer look at the loading process. Static analysis of the module loading process From the debug message, I was able to trace the location in the code where the linking process failed. The message was printed from inside __apply_relocate_add in arch/x86/kernel/module.c. The function is responsible for applying relocations to ELF sections of the module. A short excursion on relocations In generic terms, a relocation links the reference of a symbol to its definition. As an example, if a kernel module wants to call a function like printk, which it does not provide itself, it must know the address at which the function is located. Since the address is not known at compile time, it must be dynamically inserted into the module at load time. The process of performing this search and replace is defined by a relocation. The relocations that need to be applied to the kernel module at startup are stored in the ELF file along with code and data. For each section to which relocations must be applied, the module contains a .rela section with relocations. As an example, most modules feature a .text section that contains the compiled code of the module. The relocations for that section are stored in the .rela.text section. Each relocation in a .rela section consists of several values: The location relative to the start of the target section at which the relocation must be applied. A link to the symbol that must be inserted at the specified location. The type of the relocation. Relocation types are specific to a processor and define how the symbol value must be inserted at the location. An addend, however this is not strictly relevant to this post To give a quick example, below I list a relocation from the .rela.text section in the etas_es58x module: 1 2 Offset Info Type Sym. Value Sym. Name + Addend 000000000031 00c900000004 R_X86_64_PLT32 0000000000000000 memcpy - 4 The relocation specifies that the address of symbol memcpy must be placed at offset 0x31 relative to the beginning of the .text section. Analysis of the relocation error Below is the source code of __apply_relocate_add (arch/x86/kernel/module.c). The function applies all relocations contained in a single .rela section. For each relocation, it calculates the absolute address of the relocation in loc and the symbol value in val. The switch case statement that follows is responsible for applying the symbol value according to the relocation type. The function also performs a sanity check before it applies a relocation: it checks if the location in memory is properly initialized to zero. If not, it aborts with an error message. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 static int __apply_relocate_add(Elf64_Shdr *sechdrs, const char *strtab, unsigned int symindex, unsigned int relsec, struct module *me, void *(*write)(void *dest, const void *src, size_t len)) { unsigned int i; Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr; Elf64_Sym *sym; void *loc; u64 val; DEBUGP(&quot;Applying relocate section %u to %u\n&quot;, relsec, sechdrs[relsec].sh_info); for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) { /* This is where to make the change */ loc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset; /* This is the symbol it is referring to. Note that all undefined symbols have been resolved. */ sym = (Elf64_Sym *)sechdrs[symindex].sh_addr + ELF64_R_SYM(rel[i].r_info); DEBUGP(&quot;type %d st_value %Lx r_addend %Lx loc %Lx\n&quot;, (int)ELF64_R_TYPE(rel[i].r_info), sym-&gt;st_value, rel[i].r_addend, (u64)loc); val = sym-&gt;st_value + rel[i].r_addend; switch (ELF64_R_TYPE(rel[i].r_info)) { case R_X86_64_NONE: break; case R_X86_64_64: if (*(u64 *)loc != 0) goto invalid_relocation; write(loc, &amp;val, 8); break; case R_X86_64_32: if (*(u32 *)loc != 0) goto invalid_relocation; write(loc, &amp;val, 4); if (val != *(u32 *)loc) goto overflow; break; case R_X86_64_32S: if (*(s32 *)loc != 0) goto invalid_relocation; write(loc, &amp;val, 4); if ((s64)val != *(s32 *)loc) goto overflow; break; case R_X86_64_PC32: case R_X86_64_PLT32: if (*(u32 *)loc != 0) goto invalid_relocation; val -= (u64)loc; write(loc, &amp;val, 4); #if 0 if ((s64)val != *(s32 *)loc) goto overflow; #endif break; case R_X86_64_PC64: if (*(u64 *)loc != 0) goto invalid_relocation; val -= (u64)loc; write(loc, &amp;val, 8); break; default: pr_err(&quot;%s: Unknown rela relocation: %llu\n&quot;, me-&gt;name, ELF64_R_TYPE(rel[i].r_info)); return -ENOEXEC; } } return 0; invalid_relocation: pr_err(&quot;x86/modules: Skipping invalid relocation target, existing value is nonzero for type %d, loc %p, val %Lx\n&quot;, (int)ELF64_R_TYPE(rel[i].r_info), loc, val); return -ENOEXEC; overflow: pr_err(&quot;overflow in relocation type %d val %Lx\n&quot;, (int)ELF64_R_TYPE(rel[i].r_info), val); pr_err(&quot;`%s&#39; likely not compiled with -mcmodel=kernel\n&quot;, me-&gt;name); return -ENOEXEC; } This error message is the same as the one that was displayed when I tried to load my freshly-compiled module. Apparently, the dynamic linker encountered a relocation where the target address already held a non-zero value. However, a quick check with readelf -a etas_es58x.ko revealed that none of the relocation targets in the respective sections of the ELF file held a non-zero value. Consequently, the location had to have been manipulated at runtime while the module was being loaded. Unfortunately, the error message itself did not yield any useful information, like the section in which the issue occurred or the name of the affected symbol. Hence, I decided to investigate the issue further by debugging the function at runtime using QEMU. Dynamic analysis with QEMU and GDB In order to debug the kernel, I needed to set up gdb, acquire an ELF file of the compiled kernel that contained debug symbols, and disable KASLR, the kernel address space layout randomization. Setup I normally run gdb with gef which provides a convenient context print during debugging as well as some advanced features for memory inspection. Kali has a convenient package called linux-image-amd64-dbg. It contains an ELF file of the kernel with debugging symbols. However, for the debugging I needed both the source code as well as the ELF file on the host to connect to the gdb server stub of QEMU. Fortunately, with the raw image format, it was very easy to mount and copy data from the image: 1 2 3 4 5 6 7 8 $ sudo losetup -f kali_hd.raw $ sudo partprobe /dev/loop0 $ sudo mount /dev/loop0p1 /mnt $ cp -r /mnt/home/kali/linux-source-5.14/ . $ cd linux-source-5.14/ $ cp /mnt/usr/lib/debug/boot/vmlinux-5.14.0-kali4-amd64 . $ sudo umount /mnt $ sudo losetup -D I also loaded the ELF file of the kernel image into Ghidra for analysis. This allowed me to look around and do cross-referencing more easily than I was able to do from inside gdb. Lastly, I needed to disable the kernel address space layout randomization. This can be done by booting the kernel with the keyword nokaslr. I edited /etc/default/grub in the VM and added nokaslr to the following line in the file: 1 GRUB_CMDLINE_LINUX=&quot;nokaslr&quot; Then I recreated the grub configuration file: 1 $ sudo update-grub Breaking at the failing function I started the VM with the -s flag to start a gdb server on localhost:1234. Then I ran gdb and connected to the server: 1 $ gdb ./vmlinux-5.14.0-kali4-amd64 My plan was to pinpoint the relocation section and symbol that were causing the error condition by breaking at the error handler. However, due to compiler optimizations, most stack-based variable storage had been optimized away. The index of the relocation section relsec was passed into the function in the $ecx register but dropped after the absolute address of the section header had been calculated. Hence, I added two breakpoints in __apply_relocate_add. I added one breakpoint at the function start and another breakpoint at the error handler (the exact address of which I was able to determine with Ghidra). This setup allowed me to break at the function prologue to intercept the call parameters. If the second breakpoint hit right afterwards I knew that the last seen section was the offending one. 1 2 3 4 target remote localhost:1234 break apply_relocate_add break *(apply_relocate_add+0x85a08c) continue The offending module relocation I loaded the module inside the VM to trigger the breakpoint. At iteration relsec == 0x23, the second breakpoint hit, meaning that the error occurred there. The relocation section with index 0x23 was .rela.gnu.linkonce.this_module. The section contains the module struct with information (such as the name) about the module. The struct is kept in memory by the kernel and filled with runtime information. The relocation section for it featured two entries: 1 2 3 Offset Info Type Sym. Value Sym. Name + Addend 000000000138 00d400000001 R_X86_64_64 0000000000000000 init_module + 0 000000000340 00c800000001 R_X86_64_64 0000000000000000 cleanup_module + 0 The relocations tell the kernel to place the address of the init_module and the cleanup_module function at the specified offsets in the struct. One of the two relocations failed, however I didn’t yet know which one of the two. Fortunately, according to the decompiled source and assembly from Ghidra, the counter variable i in __apply_relocate_add had been placed in register r13 by the compiler, and the register was not written to for any other purpuses except the counter. This allowed me to simply dump the contents with p $r13 when the debugger hit the second breakpoint. The issue was with the second relocation for cleanup_module at index i == 1. Tracing struct module write accesses The next thing I wanted to try out was to determine what data was being written to the location. Since the offset was initialized to zero in the ELF file, it must have been written to directly before the relocation. I noticed that the module struct was first accessed quite early in the module loading process in setup_load_info of module.c: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static int setup_load_info(struct load_info *info, int flags) { ... info-&gt;index.mod = find_sec(info, &quot;.gnu.linkonce.this_module&quot;); if (!info-&gt;index.mod) { pr_warn(&quot;%s: No module found in object\n&quot;, info-&gt;name ?: &quot;(missing .modinfo section or name field)&quot;); return -ENOEXEC; } /* This is temporary: point mod into copy of data. */ info-&gt;mod = (void *)info-&gt;hdr + info-&gt;sechdrs[info-&gt;index.mod].sh_offset; ... } In the last line, info-&gt;mod is set to point to the location of the gnu.linkonce.this_module section. Successive access to the struct always uses the reference stored in info. As the comment explains, the address is only temporary since the module still has to be copied to its final location. In order to determine the address of section gnu.linkonce.this_module and hence the address of the module struct, I set a breakpoint in load_module because setup_load_info had been optimized away. 1 b *(load_module + 0x32d) Once the breakpoint hit, I set a custom watch point to break whenever the pointer to the cleanup_module function was being manipulated: 1 2 3 4 5 $ p $r13 $5 = 0xffffc90002e52c80 $ awatch *(0xffffc90002e52c80 + 0x340) Hardware access (read/write) watchpoint 2: *(0xffffc90002e52c80 + 0x340) $ continue The first time the breakpoint hit was in memcpy when the entire section was being copied to its final location in kernel memory. I added a new watchpoint to the same section offset in target memory. The new breakpoint hit in load_module+0x1025, which Ghidra presented as the following decompiled C code: 1 2 3 4 5 6 7 8 *(int **)(piVar37 + 0xce) = piVar37 + 0xcc; *(int **)(piVar37 + 0xcc) = piVar37 + 0xcc; *(int **)(piVar37 + 0xd0) = piVar37 + 0xd0; *(int **)(piVar37 + 0xd2) = piVar37 + 0xd0; LOCK(); piVar37[0xd6] = piVar37[0xd6] + 1; __mutex_init(piVar37 + 0x3a,s_&amp;mod-&gt;param_lock_ffffffff8210fe43, &amp;__key.7); uVar11 = find_sec(info,s___param_ffffffff8210fe54); The code writes some unknown data to the pointer of cleanup_module. Directly afterwards, it initializes a mutex and calls the find_sec function to determine the index of the __param section. There was only one location in the module loading code where this disassembly could have originated from - somewhat in the middle of the load_module code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* To avoid stressing percpu allocator, do this once we&#39;re unique. */ err = percpu_modalloc(mod, info); if (err) goto unlink_mod; /* Now module is in final location, initialize linked lists, etc. */ err = module_unload_init(mod); if (err) goto unlink_mod; init_param_lock(mod); /* * Now we&#39;ve got everything in the final locations, we can * find optional sections. */ err = find_module_sections(mod, info); if (err) goto free_unload; The mutex is initialized in init_param_lock and find_sec(&quot;__param&quot;) is executed in find_module_sections. Hence, the modification of the cleanup_module pointer had to occur in the module_unload_init function. And indeed, the function initialized two linked lists in struct module: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* Init the unload section of the module. */ static int module_unload_init(struct module *mod) { /* * Initialize reference counter to MODULE_REF_BASE. * refcnt == 0 means module is going. */ atomic_set(&amp;mod-&gt;refcnt, MODULE_REF_BASE); INIT_LIST_HEAD(&amp;mod-&gt;source_list); INIT_LIST_HEAD(&amp;mod-&gt;target_list); /* Hold reference count during initialization. */ atomic_inc(&amp;mod-&gt;refcnt); return 0; } In assembly, the initialization operation is even more clearly visible. 1 2 3 4 5 6 7 fff811405d7 LEA RAX,[R13 + 0x330] fff811405de MOV dword ptr [R13 + 0x358],0x1 fff811405e9 MOV qword ptr [R13 + 0x338],RAX fff811405f0 MOV qword ptr [R13 + 0x330],RAX fff811405f7 LEA RAX,[R13 + 0x340] fff811405fe MOV qword ptr [R13 + 0x340],RAX fff81140605 MOV qword ptr [R13 + 0x348],RAX Register $r13 contained the address of the module struct. The forward and backward pointers in each list were initialized to loop back to the list instance. Interestingly, the second of the two lists was clearly leaking into the cleanup_module pointer, which the relocation operation expected to be located at offset 0x340 of the struct. In the struct definition, the two linked lists were directly bordering on the cleanup_module function pointer, here called exit: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct module { // ... #ifdef CONFIG_MODULE_UNLOAD /* What modules depend on me? */ struct list_head source_list; /* What modules do I depend on? */ struct list_head target_list; /* Destruction function. */ void (*exit)(void); atomic_t refcnt; #endif // ... } To summarize the finding, the kernel module loading code and the relocations in the module were using two different, binary incompatible definitions of struct module. In the version known to the module, the exit function pointer had moved to the front of the struct by 16 Bytes. The root cause Although I had made an exact copy of the kernel configuration used by the Kali package maintainers, apparently some configuration options were manipulating the struct module definition and causing the offset. I made a diff of my local .config file and the one that shipped with the source package: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 CONFIG_DEBUG_KERNEL=y --- /usr/src/linux-headers-5.14.0-kali4-amd64/.config 2021-11-05 11:54:48.000000000 +0100 +++ .config 2021-11-22 21:41:25.519431077 +0100 @@ -2,9 +2,9 @@ # Automatically generated file; DO NOT EDIT. # Linux/x86 5.14.16 Kernel Configuration # -CONFIG_CC_VERSION_TEXT=&quot;gcc-10 (Debian 10.3.0-12) 10.3.0&quot; +CONFIG_CC_VERSION_TEXT=&quot;gcc (Debian 11.2.0-10) 11.2.0&quot; CONFIG_CC_IS_GCC=y -CONFIG_GCC_VERSION=100300 +CONFIG_GCC_VERSION=110200 CONFIG_CLANG_VERSION=0 CONFIG_AS_IS_GNU=y CONFIG_AS_VERSION=23700 @@ -14,6 +14,7 @@ CONFIG_CC_CAN_LINK=y CONFIG_CC_CAN_LINK_STATIC=y CONFIG_CC_HAS_ASM_GOTO=y +CONFIG_CC_HAS_ASM_GOTO_OUTPUT=y CONFIG_CC_HAS_ASM_INLINE=y CONFIG_CC_HAS_NO_PROFILE_FN_ATTR=y CONFIG_IRQ_WORK=y @@ -1893,7 +1894,7 @@ CONFIG_CAN_8DEV_USB=m CONFIG_CAN_EMS_USB=m CONFIG_CAN_ESD_USB2=m -# CONFIG_CAN_ETAS_ES58X is not set +CONFIG_CAN_ETAS_ES58X=m CONFIG_CAN_GS_USB=m CONFIG_CAN_KVASER_USB=m CONFIG_CAN_MCBA_USB=m @@ -9716,8 +9717,6 @@ CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y # CONFIG_DEBUG_INFO_DWARF4 is not set CONFIG_DEBUG_INFO_BTF=y -CONFIG_PAHOLE_HAS_SPLIT_BTF=y -CONFIG_DEBUG_INFO_BTF_MODULES=y # CONFIG_GDB_SCRIPTS is not set CONFIG_FRAME_WARN=2048 CONFIG_STRIP_ASM_SYMS=y @@ -9747,6 +9746,8 @@ CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL=y # CONFIG_UBSAN is not set CONFIG_HAVE_ARCH_KCSAN=y +CONFIG_HAVE_KCSAN_COMPILER=y +# CONFIG_KCSAN is not set # end of Generic Kernel Debugging Instruments CONFIG_DEBUG_KERNEL=y Of all configuration options that were different in both versions, option CONFIG_DEBUG_INFO_BTF_MODULES was the most interesting to my case. If enabled, it added two members to struct module: 1 2 3 4 5 6 7 8 struct module { // ... #ifdef CONFIG_DEBUG_INFO_BTF_MODULES unsigned int btf_data_size; void *btf_data; #endif // ... } Given the alignment requirements of amd64, the compiler would likely add 4 Byte of padding between the int and the void pointer, resulting in a size of 16 Byte for the two members. At that point I was fairly certain I had found the culprit for my issues. The only thing I did not know was why the option had been disabled. I retraced my compilation steps to determine why the option was disabled. The option seemed to be magically turned off after executing make oldconfig. After digging a little in the documentation, I found the reason: I was missing the pahole tool in my PATH. The Makefile automatically disabled the option if pahole was not found. I installed the dwarves package in Kali, recompiled the kernel module, and called insmod to insert the module into the kernel. And behold: 1 2 3 4 5 $ lsmod | grep etas etas_es58x 53248 0 usbcore 331776 1 etas_es58x can_dev 40960 1 etas_es58x crc16 16384 2 etas_es58x,ext4 The module was happy and alive. Takeaway Message When compiling a kernel module: always make sure that the configuration file doesn’t change while you’re not looking. This scenario wasn’t something I was aware of until now. And frankly, I do not consider it to be good design. Of course I don’t have the entire picture, but I believe a missing dependency should cause a build to fail fast, not produce incompatible artifacts." /><link rel="canonical" href="https://lumagi.github.io/posts/compiling-intree-linux-modules/" /><meta property="og:url" content="https://lumagi.github.io/posts/compiling-intree-linux-modules/" /><meta property="og:site_name" content="RAndom Notes on Tech" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-11T18:21:11+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Debugging Linux Module Loading with QEMU" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-04-15T19:40:53+02:00","datePublished":"2021-12-11T18:21:11+01:00","description":"My company uses the ETAS ES582.1 CAN adapters to interface with a CAN bus. Since recently, the kernel has mainline support for these devices (the etas_es58x driver). However, my work operating system of choice, Kali Linux, does not ship with a prebuilt kernel module for the devices out of the box. Hence, I needed to manually compile the module to use the devices under Kali. While doing so, I ran into binary compatibility issues and ended up debugging the module loading process with QEMU to determine the root cause. This blog post is a summary of the process. I first explain the QEMU VM installation process, explain the issues I encountered, and outline the debugging process to pinpoint the issue. Spoiler: If you arrived at this post in hopes of fixing the error message below, try installing the pahole tool. On Kali, the required package is called dwarves. If that doesn’t work, I invite you to follow this post and try debugging for yourself. On the host, I used an Arch Linux installation. The QEMU VM ran the target operating system, a Kali Linux installation. All my attempts were made on Kernel version 5.14.16. QEMU VM Setup On Arch, I merely needed to install the qemu package to get started. I then set up the VM image and started the installation. For the image, I intentionally used the raw format because it can easily be mounted on the host side as a loop device for manipulation. Additionally, for filesystems like ext4 that support holes, only non-zero blocks in the file will take up disk space. I created a rather big image to accommodate the source code and debug package. The second command starts up the VM with KVM, 4GB of memory and inserts the Kali installation disk. 1 2 $ qemu-img create -f raw kali_hd2.raw 16G $ qemu-system-x86_64 -boot order=d -drive file=kali_hd.raw,format=raw -m 4G -enable-kvm -cdrom kali-linux-2021.3a-installer-netinst-amd64.iso I installed a minimal Kali version without desktop environment and no preinstalled pentesting tools to reduce the size. Next, I ran the VM without ISO and with enabled gdb stub for attaching the debugger later on: 1 $ qemu-system-x86_64 -boot order=d -drive file=kali_hd.raw,format=raw -m 4G -enable-kvm -s Kernel Module Compilation The next step was to actually compile the module inside the VM. I used the linux-source package for maximum compatibility with the prebuilt kernel. apt automatically pulled in Kali package version 5.14.16-1kali1. 1 2 3 4 $ sudo apt-get install build-essential libncurses5-dev libelf-dev libssl-dev $ sudo apt-get install linux-source linux-headers-amd64 $ tar -xf /usr/src/linux-source-5.14.tar.xz $ cd linux-source-5.14/ Next, I prepared the sources for compilation. I copied the configuration file and module symbol version file from the linux-headers package. 1 2 $ cp /usr/src/linux-headers-5.14.0-kali4-amd64/.config . $ cp /usr/src/linux-headers-5.14.0-kali4-amd64/Module.symvers . Since the module I wanted to compile was not enabled in the .config file, I manually enabled the module by adding the following line to the file: 1 CONFIG_CAN_ETAS_ES58X=m Finally, I was able to compile the module. The first step in the series of commands checks the configuration file for completeness and queries the user for any missing configuration option. I stuck with the defaults. 1 2 3 4 $ make oldconfig $ make prepare $ make modules_prepare $ make M=drivers/net/can/usb/etas_es58x/ Next I tried to insmod the new module and its dependencies for a quick test: 1 2 3 $ for i in can-dev usbcore crc16; do sudo modprobe $i; done $ sudo insmod drivers/net/can/usb/etas_es58x/etas_es58x.ko insmod: ERROR: could not insert module drivers/net/can/usb/etas_es58x/etas_es58x.ko: Invalid module format As expected, the module insertion failed due to some unknown issue with the module. Next, I checked the kernel log: 1 2 $ sudo dmesg | tail -n 1 [ 2056.862808] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 00000000909cc68f, val ffffffffc087f984 The debug message was rather cryptic, but revealed that there seemed to be some issue with the symbol relocation during module linking. I dug up the kernel code responsible for loading the modules and took a closer look at the loading process. Static analysis of the module loading process From the debug message, I was able to trace the location in the code where the linking process failed. The message was printed from inside __apply_relocate_add in arch/x86/kernel/module.c. The function is responsible for applying relocations to ELF sections of the module. A short excursion on relocations In generic terms, a relocation links the reference of a symbol to its definition. As an example, if a kernel module wants to call a function like printk, which it does not provide itself, it must know the address at which the function is located. Since the address is not known at compile time, it must be dynamically inserted into the module at load time. The process of performing this search and replace is defined by a relocation. The relocations that need to be applied to the kernel module at startup are stored in the ELF file along with code and data. For each section to which relocations must be applied, the module contains a .rela section with relocations. As an example, most modules feature a .text section that contains the compiled code of the module. The relocations for that section are stored in the .rela.text section. Each relocation in a .rela section consists of several values: The location relative to the start of the target section at which the relocation must be applied. A link to the symbol that must be inserted at the specified location. The type of the relocation. Relocation types are specific to a processor and define how the symbol value must be inserted at the location. An addend, however this is not strictly relevant to this post To give a quick example, below I list a relocation from the .rela.text section in the etas_es58x module: 1 2 Offset Info Type Sym. Value Sym. Name + Addend 000000000031 00c900000004 R_X86_64_PLT32 0000000000000000 memcpy - 4 The relocation specifies that the address of symbol memcpy must be placed at offset 0x31 relative to the beginning of the .text section. Analysis of the relocation error Below is the source code of __apply_relocate_add (arch/x86/kernel/module.c). The function applies all relocations contained in a single .rela section. For each relocation, it calculates the absolute address of the relocation in loc and the symbol value in val. The switch case statement that follows is responsible for applying the symbol value according to the relocation type. The function also performs a sanity check before it applies a relocation: it checks if the location in memory is properly initialized to zero. If not, it aborts with an error message. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 static int __apply_relocate_add(Elf64_Shdr *sechdrs, const char *strtab, unsigned int symindex, unsigned int relsec, struct module *me, void *(*write)(void *dest, const void *src, size_t len)) { unsigned int i; Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr; Elf64_Sym *sym; void *loc; u64 val; DEBUGP(&quot;Applying relocate section %u to %u\\n&quot;, relsec, sechdrs[relsec].sh_info); for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) { /* This is where to make the change */ loc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset; /* This is the symbol it is referring to. Note that all undefined symbols have been resolved. */ sym = (Elf64_Sym *)sechdrs[symindex].sh_addr + ELF64_R_SYM(rel[i].r_info); DEBUGP(&quot;type %d st_value %Lx r_addend %Lx loc %Lx\\n&quot;, (int)ELF64_R_TYPE(rel[i].r_info), sym-&gt;st_value, rel[i].r_addend, (u64)loc); val = sym-&gt;st_value + rel[i].r_addend; switch (ELF64_R_TYPE(rel[i].r_info)) { case R_X86_64_NONE: break; case R_X86_64_64: if (*(u64 *)loc != 0) goto invalid_relocation; write(loc, &amp;val, 8); break; case R_X86_64_32: if (*(u32 *)loc != 0) goto invalid_relocation; write(loc, &amp;val, 4); if (val != *(u32 *)loc) goto overflow; break; case R_X86_64_32S: if (*(s32 *)loc != 0) goto invalid_relocation; write(loc, &amp;val, 4); if ((s64)val != *(s32 *)loc) goto overflow; break; case R_X86_64_PC32: case R_X86_64_PLT32: if (*(u32 *)loc != 0) goto invalid_relocation; val -= (u64)loc; write(loc, &amp;val, 4); #if 0 if ((s64)val != *(s32 *)loc) goto overflow; #endif break; case R_X86_64_PC64: if (*(u64 *)loc != 0) goto invalid_relocation; val -= (u64)loc; write(loc, &amp;val, 8); break; default: pr_err(&quot;%s: Unknown rela relocation: %llu\\n&quot;, me-&gt;name, ELF64_R_TYPE(rel[i].r_info)); return -ENOEXEC; } } return 0; invalid_relocation: pr_err(&quot;x86/modules: Skipping invalid relocation target, existing value is nonzero for type %d, loc %p, val %Lx\\n&quot;, (int)ELF64_R_TYPE(rel[i].r_info), loc, val); return -ENOEXEC; overflow: pr_err(&quot;overflow in relocation type %d val %Lx\\n&quot;, (int)ELF64_R_TYPE(rel[i].r_info), val); pr_err(&quot;`%s&#39; likely not compiled with -mcmodel=kernel\\n&quot;, me-&gt;name); return -ENOEXEC; } This error message is the same as the one that was displayed when I tried to load my freshly-compiled module. Apparently, the dynamic linker encountered a relocation where the target address already held a non-zero value. However, a quick check with readelf -a etas_es58x.ko revealed that none of the relocation targets in the respective sections of the ELF file held a non-zero value. Consequently, the location had to have been manipulated at runtime while the module was being loaded. Unfortunately, the error message itself did not yield any useful information, like the section in which the issue occurred or the name of the affected symbol. Hence, I decided to investigate the issue further by debugging the function at runtime using QEMU. Dynamic analysis with QEMU and GDB In order to debug the kernel, I needed to set up gdb, acquire an ELF file of the compiled kernel that contained debug symbols, and disable KASLR, the kernel address space layout randomization. Setup I normally run gdb with gef which provides a convenient context print during debugging as well as some advanced features for memory inspection. Kali has a convenient package called linux-image-amd64-dbg. It contains an ELF file of the kernel with debugging symbols. However, for the debugging I needed both the source code as well as the ELF file on the host to connect to the gdb server stub of QEMU. Fortunately, with the raw image format, it was very easy to mount and copy data from the image: 1 2 3 4 5 6 7 8 $ sudo losetup -f kali_hd.raw $ sudo partprobe /dev/loop0 $ sudo mount /dev/loop0p1 /mnt $ cp -r /mnt/home/kali/linux-source-5.14/ . $ cd linux-source-5.14/ $ cp /mnt/usr/lib/debug/boot/vmlinux-5.14.0-kali4-amd64 . $ sudo umount /mnt $ sudo losetup -D I also loaded the ELF file of the kernel image into Ghidra for analysis. This allowed me to look around and do cross-referencing more easily than I was able to do from inside gdb. Lastly, I needed to disable the kernel address space layout randomization. This can be done by booting the kernel with the keyword nokaslr. I edited /etc/default/grub in the VM and added nokaslr to the following line in the file: 1 GRUB_CMDLINE_LINUX=&quot;nokaslr&quot; Then I recreated the grub configuration file: 1 $ sudo update-grub Breaking at the failing function I started the VM with the -s flag to start a gdb server on localhost:1234. Then I ran gdb and connected to the server: 1 $ gdb ./vmlinux-5.14.0-kali4-amd64 My plan was to pinpoint the relocation section and symbol that were causing the error condition by breaking at the error handler. However, due to compiler optimizations, most stack-based variable storage had been optimized away. The index of the relocation section relsec was passed into the function in the $ecx register but dropped after the absolute address of the section header had been calculated. Hence, I added two breakpoints in __apply_relocate_add. I added one breakpoint at the function start and another breakpoint at the error handler (the exact address of which I was able to determine with Ghidra). This setup allowed me to break at the function prologue to intercept the call parameters. If the second breakpoint hit right afterwards I knew that the last seen section was the offending one. 1 2 3 4 target remote localhost:1234 break apply_relocate_add break *(apply_relocate_add+0x85a08c) continue The offending module relocation I loaded the module inside the VM to trigger the breakpoint. At iteration relsec == 0x23, the second breakpoint hit, meaning that the error occurred there. The relocation section with index 0x23 was .rela.gnu.linkonce.this_module. The section contains the module struct with information (such as the name) about the module. The struct is kept in memory by the kernel and filled with runtime information. The relocation section for it featured two entries: 1 2 3 Offset Info Type Sym. Value Sym. Name + Addend 000000000138 00d400000001 R_X86_64_64 0000000000000000 init_module + 0 000000000340 00c800000001 R_X86_64_64 0000000000000000 cleanup_module + 0 The relocations tell the kernel to place the address of the init_module and the cleanup_module function at the specified offsets in the struct. One of the two relocations failed, however I didn’t yet know which one of the two. Fortunately, according to the decompiled source and assembly from Ghidra, the counter variable i in __apply_relocate_add had been placed in register r13 by the compiler, and the register was not written to for any other purpuses except the counter. This allowed me to simply dump the contents with p $r13 when the debugger hit the second breakpoint. The issue was with the second relocation for cleanup_module at index i == 1. Tracing struct module write accesses The next thing I wanted to try out was to determine what data was being written to the location. Since the offset was initialized to zero in the ELF file, it must have been written to directly before the relocation. I noticed that the module struct was first accessed quite early in the module loading process in setup_load_info of module.c: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static int setup_load_info(struct load_info *info, int flags) { ... info-&gt;index.mod = find_sec(info, &quot;.gnu.linkonce.this_module&quot;); if (!info-&gt;index.mod) { pr_warn(&quot;%s: No module found in object\\n&quot;, info-&gt;name ?: &quot;(missing .modinfo section or name field)&quot;); return -ENOEXEC; } /* This is temporary: point mod into copy of data. */ info-&gt;mod = (void *)info-&gt;hdr + info-&gt;sechdrs[info-&gt;index.mod].sh_offset; ... } In the last line, info-&gt;mod is set to point to the location of the gnu.linkonce.this_module section. Successive access to the struct always uses the reference stored in info. As the comment explains, the address is only temporary since the module still has to be copied to its final location. In order to determine the address of section gnu.linkonce.this_module and hence the address of the module struct, I set a breakpoint in load_module because setup_load_info had been optimized away. 1 b *(load_module + 0x32d) Once the breakpoint hit, I set a custom watch point to break whenever the pointer to the cleanup_module function was being manipulated: 1 2 3 4 5 $ p $r13 $5 = 0xffffc90002e52c80 $ awatch *(0xffffc90002e52c80 + 0x340) Hardware access (read/write) watchpoint 2: *(0xffffc90002e52c80 + 0x340) $ continue The first time the breakpoint hit was in memcpy when the entire section was being copied to its final location in kernel memory. I added a new watchpoint to the same section offset in target memory. The new breakpoint hit in load_module+0x1025, which Ghidra presented as the following decompiled C code: 1 2 3 4 5 6 7 8 *(int **)(piVar37 + 0xce) = piVar37 + 0xcc; *(int **)(piVar37 + 0xcc) = piVar37 + 0xcc; *(int **)(piVar37 + 0xd0) = piVar37 + 0xd0; *(int **)(piVar37 + 0xd2) = piVar37 + 0xd0; LOCK(); piVar37[0xd6] = piVar37[0xd6] + 1; __mutex_init(piVar37 + 0x3a,s_&amp;mod-&gt;param_lock_ffffffff8210fe43, &amp;__key.7); uVar11 = find_sec(info,s___param_ffffffff8210fe54); The code writes some unknown data to the pointer of cleanup_module. Directly afterwards, it initializes a mutex and calls the find_sec function to determine the index of the __param section. There was only one location in the module loading code where this disassembly could have originated from - somewhat in the middle of the load_module code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* To avoid stressing percpu allocator, do this once we&#39;re unique. */ err = percpu_modalloc(mod, info); if (err) goto unlink_mod; /* Now module is in final location, initialize linked lists, etc. */ err = module_unload_init(mod); if (err) goto unlink_mod; init_param_lock(mod); /* * Now we&#39;ve got everything in the final locations, we can * find optional sections. */ err = find_module_sections(mod, info); if (err) goto free_unload; The mutex is initialized in init_param_lock and find_sec(&quot;__param&quot;) is executed in find_module_sections. Hence, the modification of the cleanup_module pointer had to occur in the module_unload_init function. And indeed, the function initialized two linked lists in struct module: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* Init the unload section of the module. */ static int module_unload_init(struct module *mod) { /* * Initialize reference counter to MODULE_REF_BASE. * refcnt == 0 means module is going. */ atomic_set(&amp;mod-&gt;refcnt, MODULE_REF_BASE); INIT_LIST_HEAD(&amp;mod-&gt;source_list); INIT_LIST_HEAD(&amp;mod-&gt;target_list); /* Hold reference count during initialization. */ atomic_inc(&amp;mod-&gt;refcnt); return 0; } In assembly, the initialization operation is even more clearly visible. 1 2 3 4 5 6 7 fff811405d7 LEA RAX,[R13 + 0x330] fff811405de MOV dword ptr [R13 + 0x358],0x1 fff811405e9 MOV qword ptr [R13 + 0x338],RAX fff811405f0 MOV qword ptr [R13 + 0x330],RAX fff811405f7 LEA RAX,[R13 + 0x340] fff811405fe MOV qword ptr [R13 + 0x340],RAX fff81140605 MOV qword ptr [R13 + 0x348],RAX Register $r13 contained the address of the module struct. The forward and backward pointers in each list were initialized to loop back to the list instance. Interestingly, the second of the two lists was clearly leaking into the cleanup_module pointer, which the relocation operation expected to be located at offset 0x340 of the struct. In the struct definition, the two linked lists were directly bordering on the cleanup_module function pointer, here called exit: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct module { // ... #ifdef CONFIG_MODULE_UNLOAD /* What modules depend on me? */ struct list_head source_list; /* What modules do I depend on? */ struct list_head target_list; /* Destruction function. */ void (*exit)(void); atomic_t refcnt; #endif // ... } To summarize the finding, the kernel module loading code and the relocations in the module were using two different, binary incompatible definitions of struct module. In the version known to the module, the exit function pointer had moved to the front of the struct by 16 Bytes. The root cause Although I had made an exact copy of the kernel configuration used by the Kali package maintainers, apparently some configuration options were manipulating the struct module definition and causing the offset. I made a diff of my local .config file and the one that shipped with the source package: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 CONFIG_DEBUG_KERNEL=y --- /usr/src/linux-headers-5.14.0-kali4-amd64/.config 2021-11-05 11:54:48.000000000 +0100 +++ .config 2021-11-22 21:41:25.519431077 +0100 @@ -2,9 +2,9 @@ # Automatically generated file; DO NOT EDIT. # Linux/x86 5.14.16 Kernel Configuration # -CONFIG_CC_VERSION_TEXT=&quot;gcc-10 (Debian 10.3.0-12) 10.3.0&quot; +CONFIG_CC_VERSION_TEXT=&quot;gcc (Debian 11.2.0-10) 11.2.0&quot; CONFIG_CC_IS_GCC=y -CONFIG_GCC_VERSION=100300 +CONFIG_GCC_VERSION=110200 CONFIG_CLANG_VERSION=0 CONFIG_AS_IS_GNU=y CONFIG_AS_VERSION=23700 @@ -14,6 +14,7 @@ CONFIG_CC_CAN_LINK=y CONFIG_CC_CAN_LINK_STATIC=y CONFIG_CC_HAS_ASM_GOTO=y +CONFIG_CC_HAS_ASM_GOTO_OUTPUT=y CONFIG_CC_HAS_ASM_INLINE=y CONFIG_CC_HAS_NO_PROFILE_FN_ATTR=y CONFIG_IRQ_WORK=y @@ -1893,7 +1894,7 @@ CONFIG_CAN_8DEV_USB=m CONFIG_CAN_EMS_USB=m CONFIG_CAN_ESD_USB2=m -# CONFIG_CAN_ETAS_ES58X is not set +CONFIG_CAN_ETAS_ES58X=m CONFIG_CAN_GS_USB=m CONFIG_CAN_KVASER_USB=m CONFIG_CAN_MCBA_USB=m @@ -9716,8 +9717,6 @@ CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y # CONFIG_DEBUG_INFO_DWARF4 is not set CONFIG_DEBUG_INFO_BTF=y -CONFIG_PAHOLE_HAS_SPLIT_BTF=y -CONFIG_DEBUG_INFO_BTF_MODULES=y # CONFIG_GDB_SCRIPTS is not set CONFIG_FRAME_WARN=2048 CONFIG_STRIP_ASM_SYMS=y @@ -9747,6 +9746,8 @@ CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL=y # CONFIG_UBSAN is not set CONFIG_HAVE_ARCH_KCSAN=y +CONFIG_HAVE_KCSAN_COMPILER=y +# CONFIG_KCSAN is not set # end of Generic Kernel Debugging Instruments CONFIG_DEBUG_KERNEL=y Of all configuration options that were different in both versions, option CONFIG_DEBUG_INFO_BTF_MODULES was the most interesting to my case. If enabled, it added two members to struct module: 1 2 3 4 5 6 7 8 struct module { // ... #ifdef CONFIG_DEBUG_INFO_BTF_MODULES unsigned int btf_data_size; void *btf_data; #endif // ... } Given the alignment requirements of amd64, the compiler would likely add 4 Byte of padding between the int and the void pointer, resulting in a size of 16 Byte for the two members. At that point I was fairly certain I had found the culprit for my issues. The only thing I did not know was why the option had been disabled. I retraced my compilation steps to determine why the option was disabled. The option seemed to be magically turned off after executing make oldconfig. After digging a little in the documentation, I found the reason: I was missing the pahole tool in my PATH. The Makefile automatically disabled the option if pahole was not found. I installed the dwarves package in Kali, recompiled the kernel module, and called insmod to insert the module into the kernel. And behold: 1 2 3 4 5 $ lsmod | grep etas etas_es58x 53248 0 usbcore 331776 1 etas_es58x can_dev 40960 1 etas_es58x crc16 16384 2 etas_es58x,ext4 The module was happy and alive. Takeaway Message When compiling a kernel module: always make sure that the configuration file doesn’t change while you’re not looking. This scenario wasn’t something I was aware of until now. And frankly, I do not consider it to be good design. Of course I don’t have the entire picture, but I believe a missing dependency should cause a build to fail fast, not produce incompatible artifacts.","headline":"Debugging Linux Module Loading with QEMU","mainEntityOfPage":{"@type":"WebPage","@id":"https://lumagi.github.io/posts/compiling-intree-linux-modules/"},"url":"https://lumagi.github.io/posts/compiling-intree-linux-modules/"}</script><title>Debugging Linux Module Loading with QEMU | RAndom Notes on Tech</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="RAndom Notes on Tech"><meta name="application-name" content="RAndom Notes on Tech"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">RAndom Notes on Tech</a></div><div class="site-subtitle font-italic">Random pieces of wisdom</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/lumagi" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Debugging Linux Module Loading with QEMU</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Debugging Linux Module Loading with QEMU</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/lumagi">Lukas Magel</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1639243271" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2021-12-11 </em> </span> <span> Updated <em class="timeago" data-ts="1650044453" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-15 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3572 words"> <em>19 min</em> read</span></div></div></div><div class="post-content"><p><img data-src="/assets/images/2021_11_21-kdebug-gef-crop.png" alt="Header Image" data-proofer-ignore></p><p>My company uses the ETAS ES582.1 CAN adapters to interface with a CAN bus. Since recently, the kernel has mainline support for these devices (the <em>etas_es58x</em> driver). However, my work operating system of choice, Kali Linux, does not ship with a prebuilt kernel module for the devices out of the box. Hence, I needed to manually compile the module to use the devices under Kali. While doing so, I ran into binary compatibility issues and ended up debugging the module loading process with QEMU to determine the root cause. This blog post is a summary of the process. I first explain the QEMU VM installation process, explain the issues I encountered, and outline the debugging process to pinpoint the issue.</p><blockquote class="prompt-tip"><div><p>Spoiler: If you arrived at this post in hopes of fixing the error message below, try installing the <code class="language-plaintext highlighter-rouge">pahole</code> tool. On Kali, the required package is called <code class="language-plaintext highlighter-rouge">dwarves</code>. If that doesn’t work, I invite you to follow this post and try debugging for yourself.</p></div></blockquote><p>On the host, I used an Arch Linux installation. The QEMU VM ran the target operating system, a Kali Linux installation. All my attempts were made on Kernel version <em>5.14.16</em>.</p><h2 id="qemu-vm-setup"><span class="mr-2">QEMU VM Setup</span><a href="#qemu-vm-setup" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>On Arch, I merely needed to install the <code class="language-plaintext highlighter-rouge">qemu</code> package to get started. I then set up the VM image and started the installation. For the image, I intentionally used the <em>raw</em> format because it can easily be mounted on the host side as a loop device for manipulation. Additionally, for filesystems like <code class="language-plaintext highlighter-rouge">ext4</code> that support <em>holes</em>, only non-zero blocks in the file will take up disk space. I created a rather big image to accommodate the source code and debug package. The second command starts up the VM with KVM, 4GB of memory and inserts the Kali installation disk.</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="gp">$</span><span class="w"> </span>qemu-img create <span class="nt">-f</span> raw kali_hd2.raw 16G
<span class="gp">$</span><span class="w"> </span>qemu-system-x86_64 <span class="nt">-boot</span> <span class="nv">order</span><span class="o">=</span>d <span class="nt">-drive</span> <span class="nv">file</span><span class="o">=</span>kali_hd.raw,format<span class="o">=</span>raw <span class="nt">-m</span> 4G <span class="nt">-enable-kvm</span> <span class="nt">-cdrom</span> kali-linux-2021.3a-installer-netinst-amd64.iso
</pre></table></code></div></div><p>I installed a minimal Kali version without desktop environment and no preinstalled pentesting tools to reduce the size. Next, I ran the VM without ISO and with enabled gdb stub for attaching the debugger later on:</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="gp">$</span><span class="w"> </span>qemu-system-x86_64 <span class="nt">-boot</span> <span class="nv">order</span><span class="o">=</span>d <span class="nt">-drive</span> <span class="nv">file</span><span class="o">=</span>kali_hd.raw,format<span class="o">=</span>raw <span class="nt">-m</span> 4G <span class="nt">-enable-kvm</span> <span class="nt">-s</span>
</pre></table></code></div></div><h2 id="kernel-module-compilation"><span class="mr-2">Kernel Module Compilation</span><a href="#kernel-module-compilation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The next step was to actually compile the module inside the VM. I used the <code class="language-plaintext highlighter-rouge">linux-source</code> package for maximum compatibility with the prebuilt kernel. apt automatically pulled in Kali package version <em>5.14.16-1kali1</em>.</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>build-essential libncurses5-dev libelf-dev libssl-dev
<span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>linux-source linux-headers-amd64
<span class="gp">$</span><span class="w"> </span><span class="nb">tar</span> <span class="nt">-xf</span> /usr/src/linux-source-5.14.tar.xz
<span class="gp">$</span><span class="w"> </span><span class="nb">cd </span>linux-source-5.14/
</pre></table></code></div></div><p>Next, I prepared the sources for compilation. I copied the configuration file and module symbol version file from the <code class="language-plaintext highlighter-rouge">linux-headers</code> package.</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="gp">$</span><span class="w"> </span><span class="nb">cp</span> /usr/src/linux-headers-5.14.0-kali4-amd64/.config <span class="nb">.</span>
<span class="gp">$</span><span class="w"> </span><span class="nb">cp</span> /usr/src/linux-headers-5.14.0-kali4-amd64/Module.symvers <span class="nb">.</span>
</pre></table></code></div></div><p>Since the module I wanted to compile was not enabled in the <code class="language-plaintext highlighter-rouge">.config</code> file, I manually enabled the module by adding the following line to the file:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>CONFIG_CAN_ETAS_ES58X=m
</pre></table></code></div></div><p>Finally, I was able to compile the module. The first step in the series of commands checks the configuration file for completeness and queries the user for any missing configuration option. I stuck with the defaults.</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="gp">$</span><span class="w"> </span>make oldconfig
<span class="gp">$</span><span class="w"> </span>make prepare
<span class="gp">$</span><span class="w"> </span>make modules_prepare
<span class="gp">$</span><span class="w"> </span>make <span class="nv">M</span><span class="o">=</span>drivers/net/can/usb/etas_es58x/
</pre></table></code></div></div><p>Next I tried to <code class="language-plaintext highlighter-rouge">insmod</code> the new module and its dependencies for a quick test:</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="gp">$</span><span class="w"> </span><span class="k">for </span>i <span class="k">in </span>can-dev usbcore crc16<span class="p">;</span> <span class="k">do </span><span class="nb">sudo </span>modprobe <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span>
<span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>insmod drivers/net/can/usb/etas_es58x/etas_es58x.ko
<span class="go">insmod: ERROR: could not insert module drivers/net/can/usb/etas_es58x/etas_es58x.ko: Invalid module format
</span></pre></table></code></div></div><p>As expected, the module insertion failed due to some unknown issue with the module. Next, I checked the kernel log:</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>dmesg | <span class="nb">tail</span> <span class="nt">-n</span> 1
<span class="go">[ 2056.862808] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 00000000909cc68f, val ffffffffc087f984
</span></pre></table></code></div></div><p>The debug message was rather cryptic, but revealed that there seemed to be some issue with the symbol relocation during module linking. I dug up the kernel code responsible for loading the modules and took a closer look at the loading process.</p><h2 id="static-analysis-of-the-module-loading-process"><span class="mr-2">Static analysis of the module loading process</span><a href="#static-analysis-of-the-module-loading-process" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>From the debug message, I was able to trace the location in the code where the linking process failed. The message was printed from inside <code class="language-plaintext highlighter-rouge">__apply_relocate_add</code> in <a href="https://github.com/torvalds/linux/blob/7d2a07b769330c34b4deabeed939325c77a7ec2f/arch/x86/kernel/module.c#L130">arch/x86/kernel/module.c</a>. The function is responsible for applying relocations to ELF sections of the module.</p><h3 id="a-short-excursion-on-relocations"><span class="mr-2">A short excursion on relocations</span><a href="#a-short-excursion-on-relocations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>In generic terms, a relocation links the reference of a symbol to its definition. As an example, if a kernel module wants to call a function like <code class="language-plaintext highlighter-rouge">printk</code>, which it does not provide itself, it must know the address at which the function is located. Since the address is not known at compile time, it must be dynamically inserted into the module at load time. The process of performing this search and replace is defined by a relocation.</p><p>The relocations that need to be applied to the kernel module at startup are stored in the ELF file along with code and data. For each section to which relocations must be applied, the module contains a <code class="language-plaintext highlighter-rouge">.rela</code> section with relocations. As an example, most modules feature a <code class="language-plaintext highlighter-rouge">.text</code> section that contains the compiled code of the module. The relocations for that section are stored in the <code class="language-plaintext highlighter-rouge">.rela.text</code> section.</p><p>Each relocation in a <code class="language-plaintext highlighter-rouge">.rela</code> section consists of several values:</p><ul><li>The location relative to the start of the target section at which the relocation must be applied.<li>A link to the symbol that must be inserted at the specified location.<li>The type of the relocation. Relocation types are specific to a processor and define how the symbol value must be inserted at the location.<li>An addend, however this is not strictly relevant to this post</ul><p>To give a quick example, below I list a relocation from the <code class="language-plaintext highlighter-rouge">.rela.text</code> section in the <em>etas_es58x</em> module:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000031  00c900000004 R_X86_64_PLT32    0000000000000000 memcpy - 4
</pre></table></code></div></div><p>The relocation specifies that the address of symbol <code class="language-plaintext highlighter-rouge">memcpy</code> must be placed at offset <code class="language-plaintext highlighter-rouge">0x31</code> relative to the beginning of the <code class="language-plaintext highlighter-rouge">.text</code> section.</p><h3 id="analysis-of-the-relocation-error"><span class="mr-2">Analysis of the relocation error</span><a href="#analysis-of-the-relocation-error" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Below is the source code of <code class="language-plaintext highlighter-rouge">__apply_relocate_add</code> (<a href="https://github.com/torvalds/linux/blob/7d2a07b769330c34b4deabeed939325c77a7ec2f/arch/x86/kernel/module.c#L130">arch/x86/kernel/module.c</a>). The function applies all relocations contained in a single <code class="language-plaintext highlighter-rouge">.rela</code> section. For each relocation, it calculates the absolute address of the relocation in <code class="language-plaintext highlighter-rouge">loc</code> and the symbol value in <code class="language-plaintext highlighter-rouge">val</code>. The switch case statement that follows is responsible for applying the symbol value according to the relocation type. The function also performs a sanity check before it applies a relocation: it checks if the location in memory is properly initialized to zero. If not, it aborts with an error message.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">__apply_relocate_add</span><span class="p">(</span><span class="n">Elf64_Shdr</span> <span class="o">*</span><span class="n">sechdrs</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strtab</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">symindex</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">relsec</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">,</span>
		   <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">Elf64_Rela</span> <span class="o">*</span><span class="n">rel</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_addr</span><span class="p">;</span>
	<span class="n">Elf64_Sym</span> <span class="o">*</span><span class="n">sym</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">loc</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">DEBUGP</span><span class="p">(</span><span class="s">"Applying relocate section %u to %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	       <span class="n">relsec</span><span class="p">,</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_info</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rel</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is where to make the change */</span>
		<span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">relsec</span><span class="p">].</span><span class="n">sh_info</span><span class="p">].</span><span class="n">sh_addr</span>
			<span class="o">+</span> <span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_offset</span><span class="p">;</span>

		<span class="cm">/* This is the symbol it is referring to.  Note that all
		   undefined symbols have been resolved.  */</span>
		<span class="n">sym</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf64_Sym</span> <span class="o">*</span><span class="p">)</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">symindex</span><span class="p">].</span><span class="n">sh_addr</span>
			<span class="o">+</span> <span class="n">ELF64_R_SYM</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">);</span>

		<span class="n">DEBUGP</span><span class="p">(</span><span class="s">"type %d st_value %Lx r_addend %Lx loc %Lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">),</span>
		       <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span><span class="p">,</span> <span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_addend</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">loc</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_value</span> <span class="o">+</span> <span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_addend</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">R_X86_64_NONE</span><span class="p">:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_X86_64_64</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">invalid_relocation</span><span class="p">;</span>
			<span class="n">write</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_X86_64_32</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">invalid_relocation</span><span class="p">;</span>
			<span class="n">write</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">loc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_X86_64_32S</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">s32</span> <span class="o">*</span><span class="p">)</span><span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">invalid_relocation</span><span class="p">;</span>
			<span class="n">write</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">val</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">s32</span> <span class="o">*</span><span class="p">)</span><span class="n">loc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_X86_64_PC32</span><span class="p">:</span>
		<span class="k">case</span> <span class="n">R_X86_64_PLT32</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">invalid_relocation</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">-=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">loc</span><span class="p">;</span>
			<span class="n">write</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="c">#if 0
			if ((s64)val != *(s32 *)loc)
				goto overflow;
#endif
</span>			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">R_X86_64_PC64</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">invalid_relocation</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">-=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">loc</span><span class="p">;</span>
			<span class="n">write</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">"%s: Unknown rela relocation: %llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			       <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">invalid_relocation:</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">"x86/modules: Skipping invalid relocation target, existing value is nonzero for type %d, loc %p, val %Lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">),</span> <span class="n">loc</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>

<span class="nl">overflow:</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">"overflow in relocation type %d val %Lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ELF64_R_TYPE</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r_info</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">"`%s' likely not compiled with -mcmodel=kernel</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	       <span class="n">me</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This error message is the same as the one that was displayed when I tried to load my freshly-compiled module. Apparently, the dynamic linker encountered a relocation where the target address already held a non-zero value. However, a quick check with <code class="language-plaintext highlighter-rouge">readelf -a etas_es58x.ko</code> revealed that none of the relocation targets in the respective sections of the ELF file held a non-zero value. Consequently, the location had to have been manipulated at runtime while the module was being loaded. Unfortunately, the error message itself did not yield any useful information, like the section in which the issue occurred or the name of the affected symbol. Hence, I decided to investigate the issue further by debugging the function at runtime using QEMU.</p><h2 id="dynamic-analysis-with-qemu-and-gdb"><span class="mr-2">Dynamic analysis with QEMU and GDB</span><a href="#dynamic-analysis-with-qemu-and-gdb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In order to debug the kernel, I needed to set up gdb, acquire an ELF file of the compiled kernel that contained debug symbols, and disable KASLR, the kernel address space layout randomization.</p><h3 id="setup"><span class="mr-2">Setup</span><a href="#setup" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>I normally run gdb with <a href="https://github.com/hugsy/gef">gef</a> which provides a convenient context print during debugging as well as some advanced features for memory inspection.</p><p>Kali has a convenient package called <code class="language-plaintext highlighter-rouge">linux-image-amd64-dbg</code>. It contains an ELF file of the kernel with debugging symbols. However, for the debugging I needed both the source code as well as the ELF file on the host to connect to the gdb server stub of QEMU. Fortunately, with the raw image format, it was very easy to mount and copy data from the image:</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>losetup <span class="nt">-f</span> kali_hd.raw
<span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>partprobe /dev/loop0
<span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>mount /dev/loop0p1 /mnt
<span class="gp">$</span><span class="w"> </span><span class="nb">cp</span> <span class="nt">-r</span> /mnt/home/kali/linux-source-5.14/ <span class="nb">.</span>
<span class="gp">$</span><span class="w"> </span><span class="nb">cd </span>linux-source-5.14/
<span class="gp">$</span><span class="w"> </span><span class="nb">cp</span> /mnt/usr/lib/debug/boot/vmlinux-5.14.0-kali4-amd64 <span class="nb">.</span>
<span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>umount /mnt
<span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>losetup <span class="nt">-D</span>
</pre></table></code></div></div><p>I also loaded the ELF file of the kernel image into Ghidra for analysis. This allowed me to look around and do cross-referencing more easily than I was able to do from inside gdb.</p><p>Lastly, I needed to disable the kernel address space layout randomization. This can be done by booting the kernel with the keyword <code class="language-plaintext highlighter-rouge">nokaslr</code>. I edited <code class="language-plaintext highlighter-rouge">/etc/default/grub</code> in the VM and added <code class="language-plaintext highlighter-rouge">nokaslr</code> to the following line in the file:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>GRUB_CMDLINE_LINUX="nokaslr"
</pre></table></code></div></div><p>Then I recreated the grub configuration file:</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="gp">$</span><span class="w"> </span><span class="nb">sudo </span>update-grub
</pre></table></code></div></div><h3 id="breaking-at-the-failing-function"><span class="mr-2">Breaking at the failing function</span><a href="#breaking-at-the-failing-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>I started the VM with the <code class="language-plaintext highlighter-rouge">-s</code> flag to start a gdb server on <code class="language-plaintext highlighter-rouge">localhost:1234</code>. Then I ran gdb and connected to the server:</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="gp">$</span><span class="w"> </span>gdb ./vmlinux-5.14.0-kali4-amd64
</pre></table></code></div></div><p>My plan was to pinpoint the relocation section and symbol that were causing the error condition by breaking at the error handler. However, due to compiler optimizations, most stack-based variable storage had been optimized away. The index of the relocation section <code class="language-plaintext highlighter-rouge">relsec</code> was passed into the function in the <code class="language-plaintext highlighter-rouge">$ecx</code> register but dropped after the absolute address of the section header had been calculated. Hence, I added two breakpoints in <code class="language-plaintext highlighter-rouge">__apply_relocate_add</code>. I added one breakpoint at the function start and another breakpoint at the error handler (the exact address of which I was able to determine with Ghidra). This setup allowed me to break at the function prologue to intercept the call parameters. If the second breakpoint hit right afterwards I knew that the last seen section was the offending one.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>target remote localhost:1234
break apply_relocate_add
break *(apply_relocate_add+0x85a08c)
continue
</pre></table></code></div></div><h3 id="the-offending-module-relocation"><span class="mr-2">The offending module relocation</span><a href="#the-offending-module-relocation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>I loaded the module inside the VM to trigger the breakpoint. At iteration <code class="language-plaintext highlighter-rouge">relsec == 0x23</code>, the second breakpoint hit, meaning that the error occurred there. The relocation section with index <code class="language-plaintext highlighter-rouge">0x23</code> was <code class="language-plaintext highlighter-rouge">.rela.gnu.linkonce.this_module</code>. The section contains <a href="https://elixir.bootlin.com/linux/v5.14.16/source/include/linux/module.h#L364">the module struct</a> with information (such as the name) about the module. The struct is kept in memory by the kernel and filled with runtime information. The relocation section for it featured two entries:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000138  00d400000001 R_X86_64_64       0000000000000000 init_module + 0
000000000340  00c800000001 R_X86_64_64       0000000000000000 cleanup_module + 0
</pre></table></code></div></div><p>The relocations tell the kernel to place the address of the <code class="language-plaintext highlighter-rouge">init_module</code> and the <code class="language-plaintext highlighter-rouge">cleanup_module</code> function at the specified offsets in the struct. One of the two relocations failed, however I didn’t yet know which one of the two. Fortunately, according to the decompiled source and assembly from Ghidra, the counter variable <code class="language-plaintext highlighter-rouge">i</code> in <code class="language-plaintext highlighter-rouge">__apply_relocate_add</code> had been placed in register <code class="language-plaintext highlighter-rouge">r13</code> by the compiler, and the register was not written to for any other purpuses except the counter. This allowed me to simply dump the contents with <code class="language-plaintext highlighter-rouge">p $r13</code> when the debugger hit the second breakpoint. The issue was with the second relocation for <code class="language-plaintext highlighter-rouge">cleanup_module</code> at index <code class="language-plaintext highlighter-rouge">i == 1</code>.</p><h3 id="tracing-struct-module-write-accesses"><span class="mr-2">Tracing struct module write accesses</span><a href="#tracing-struct-module-write-accesses" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The next thing I wanted to try out was to determine what data was being written to the location. Since the offset was initialized to zero in the ELF file, it must have been written to directly before the relocation. I noticed that the module struct was first accessed quite early in the module loading process in <code class="language-plaintext highlighter-rouge">setup_load_info</code> of <a href="https://elixir.bootlin.com/linux/v5.14.16/source/kernel/module.c#L3202">module.c</a>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_load_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">find_sec</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">".gnu.linkonce.this_module"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">"%s: No module found in object</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">?:</span> <span class="s">"(missing .modinfo section or name field)"</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* This is temporary: point mod into copy of data. */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mod</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">sechdrs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">mod</span><span class="p">].</span><span class="n">sh_offset</span><span class="p">;</span>

	<span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In the last line, <code class="language-plaintext highlighter-rouge">info-&gt;mod</code> is set to point to the location of the <code class="language-plaintext highlighter-rouge">gnu.linkonce.this_module</code> section. Successive access to the struct always uses the reference stored in <code class="language-plaintext highlighter-rouge">info</code>. As the comment explains, the address is only temporary since the module still has to be copied to its final location.</p><p>In order to determine the address of section <code class="language-plaintext highlighter-rouge">gnu.linkonce.this_module</code> and hence the address of the module struct, I set a breakpoint in <code class="language-plaintext highlighter-rouge">load_module</code> because <code class="language-plaintext highlighter-rouge">setup_load_info</code> had been optimized away.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>b *(load_module + 0x32d)
</pre></table></code></div></div><p>Once the breakpoint hit, I set a custom watch point to break whenever the pointer to the <code class="language-plaintext highlighter-rouge">cleanup_module</code> function was being manipulated:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>$ p $r13
$5 = 0xffffc90002e52c80
$ awatch *(0xffffc90002e52c80 + 0x340)
Hardware access (read/write) watchpoint 2: *(0xffffc90002e52c80 + 0x340)
$ continue
</pre></table></code></div></div><p>The first time the breakpoint hit was in <code class="language-plaintext highlighter-rouge">memcpy</code> when the entire section was being copied to its final location in kernel memory. I added a new watchpoint to the same section offset in target memory. The new breakpoint hit in <code class="language-plaintext highlighter-rouge">load_module+0x1025</code>, which Ghidra presented as the following decompiled C code:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>	<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)(</span><span class="n">piVar37</span> <span class="o">+</span> <span class="mh">0xce</span><span class="p">)</span> <span class="o">=</span> <span class="n">piVar37</span> <span class="o">+</span> <span class="mh">0xcc</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)(</span><span class="n">piVar37</span> <span class="o">+</span> <span class="mh">0xcc</span><span class="p">)</span> <span class="o">=</span> <span class="n">piVar37</span> <span class="o">+</span> <span class="mh">0xcc</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)(</span><span class="n">piVar37</span> <span class="o">+</span> <span class="mh">0xd0</span><span class="p">)</span> <span class="o">=</span> <span class="n">piVar37</span> <span class="o">+</span> <span class="mh">0xd0</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)(</span><span class="n">piVar37</span> <span class="o">+</span> <span class="mh">0xd2</span><span class="p">)</span> <span class="o">=</span> <span class="n">piVar37</span> <span class="o">+</span> <span class="mh">0xd0</span><span class="p">;</span>
	<span class="n">LOCK</span><span class="p">();</span>
	<span class="n">piVar37</span><span class="p">[</span><span class="mh">0xd6</span><span class="p">]</span> <span class="o">=</span> <span class="n">piVar37</span><span class="p">[</span><span class="mh">0xd6</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__mutex_init</span><span class="p">(</span><span class="n">piVar37</span> <span class="o">+</span> <span class="mh">0x3a</span><span class="p">,</span><span class="n">s_</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">param_lock_ffffffff8210fe43</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__key</span><span class="p">.</span><span class="mi">7</span><span class="p">);</span>
	<span class="n">uVar11</span> <span class="o">=</span> <span class="n">find_sec</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">s___param_ffffffff8210fe54</span><span class="p">);</span>
</pre></table></code></div></div><p>The code writes some unknown data to the pointer of <code class="language-plaintext highlighter-rouge">cleanup_module</code>. Directly afterwards, it initializes a mutex and calls the <code class="language-plaintext highlighter-rouge">find_sec</code> function to determine the index of the <code class="language-plaintext highlighter-rouge">__param</code> section. There was only one location in the module loading code where this disassembly could have originated from - somewhat in the middle of the <a href="https://elixir.bootlin.com/linux/v5.14.16/source/kernel/module.c#L4011">load_module code</a>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>	<span class="cm">/* To avoid stressing percpu allocator, do this once we're unique. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">percpu_modalloc</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlink_mod</span><span class="p">;</span>

	<span class="cm">/* Now module is in final location, initialize linked lists, etc. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">module_unload_init</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlink_mod</span><span class="p">;</span>

	<span class="n">init_param_lock</span><span class="p">(</span><span class="n">mod</span><span class="p">);</span>

	<span class="cm">/*
	 * Now we've got everything in the final locations, we can
	 * find optional sections.
	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">find_module_sections</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_unload</span><span class="p">;</span>
</pre></table></code></div></div><p>The mutex is initialized in <code class="language-plaintext highlighter-rouge">init_param_lock</code> and <code class="language-plaintext highlighter-rouge">find_sec("__param")</code> is executed in <code class="language-plaintext highlighter-rouge">find_module_sections</code>. Hence, the modification of the <code class="language-plaintext highlighter-rouge">cleanup_module</code> pointer had to occur in the <code class="language-plaintext highlighter-rouge">module_unload_init</code> function. And indeed, the function initialized two linked lists in <code class="language-plaintext highlighter-rouge">struct module</code>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cm">/* Init the unload section of the module. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">module_unload_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*
	 * Initialize reference counter to MODULE_REF_BASE.
	 * refcnt == 0 means module is going.
	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="n">MODULE_REF_BASE</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">source_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">target_list</span><span class="p">);</span>

	<span class="cm">/* Hold reference count during initialization. */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mod</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In assembly, the initialization operation is even more clearly visible.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>     fff811405d7                 LEA        RAX,[R13 + 0x330]
     fff811405de                 MOV        dword ptr [R13 + 0x358],0x1
     fff811405e9                 MOV        qword ptr [R13 + 0x338],RAX
     fff811405f0                 MOV        qword ptr [R13 + 0x330],RAX
     fff811405f7                 LEA        RAX,[R13 + 0x340]
     fff811405fe                 MOV        qword ptr [R13 + 0x340],RAX
     fff81140605                 MOV        qword ptr [R13 + 0x348],RAX
</pre></table></code></div></div><p>Register <code class="language-plaintext highlighter-rouge">$r13</code> contained the address of the module struct. The forward and backward pointers in each list were initialized to loop back to the list instance. Interestingly, the second of the two lists was clearly leaking into the <code class="language-plaintext highlighter-rouge">cleanup_module</code> pointer, which the relocation operation expected to be located at offset <code class="language-plaintext highlighter-rouge">0x340</code> of the struct. In the struct definition, the two linked lists were directly bordering on the <code class="language-plaintext highlighter-rouge">cleanup_module</code> function pointer, here called <code class="language-plaintext highlighter-rouge">exit</code>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">module</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="cp">#ifdef CONFIG_MODULE_UNLOAD
</span>	<span class="cm">/* What modules depend on me? */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">source_list</span><span class="p">;</span>
	<span class="cm">/* What modules do I depend on? */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">target_list</span><span class="p">;</span>

	<span class="cm">/* Destruction function. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exit</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="n">atomic_t</span> <span class="n">refcnt</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>To summarize the finding, the kernel module loading code and the relocations in the module were using two different, binary incompatible definitions of <code class="language-plaintext highlighter-rouge">struct module</code>. In the version known to the module, the <code class="language-plaintext highlighter-rouge">exit</code> function pointer had moved to the front of the struct by 16 Bytes.</p><h2 id="the-root-cause"><span class="mr-2">The root cause</span><a href="#the-root-cause" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Although I had made an exact copy of the kernel configuration used by the Kali package maintainers, apparently some configuration options were manipulating the <code class="language-plaintext highlighter-rouge">struct module</code> definition and causing the offset. I made a diff of my local <code class="language-plaintext highlighter-rouge">.config</code> file and the one that shipped with the source package:</p><div class="language-diff highlighter-rouge"><div class="code-header"> <span data-label-text="Diff"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre> CONFIG_DEBUG_KERNEL=y
<span class="gd">--- /usr/src/linux-headers-5.14.0-kali4-amd64/.config   2021-11-05 11:54:48.000000000 +0100
</span><span class="gi">+++ .config     2021-11-22 21:41:25.519431077 +0100
</span><span class="p">@@ -2,9 +2,9 @@</span>
 # Automatically generated file; DO NOT EDIT.
 # Linux/x86 5.14.16 Kernel Configuration
 #
<span class="gd">-CONFIG_CC_VERSION_TEXT="gcc-10 (Debian 10.3.0-12) 10.3.0"
</span><span class="gi">+CONFIG_CC_VERSION_TEXT="gcc (Debian 11.2.0-10) 11.2.0"
</span> CONFIG_CC_IS_GCC=y
<span class="gd">-CONFIG_GCC_VERSION=100300
</span><span class="gi">+CONFIG_GCC_VERSION=110200
</span> CONFIG_CLANG_VERSION=0
 CONFIG_AS_IS_GNU=y
 CONFIG_AS_VERSION=23700
<span class="p">@@ -14,6 +14,7 @@</span>
 CONFIG_CC_CAN_LINK=y
 CONFIG_CC_CAN_LINK_STATIC=y
 CONFIG_CC_HAS_ASM_GOTO=y
<span class="gi">+CONFIG_CC_HAS_ASM_GOTO_OUTPUT=y
</span> CONFIG_CC_HAS_ASM_INLINE=y
 CONFIG_CC_HAS_NO_PROFILE_FN_ATTR=y
 CONFIG_IRQ_WORK=y
<span class="p">@@ -1893,7 +1894,7 @@</span>
 CONFIG_CAN_8DEV_USB=m
 CONFIG_CAN_EMS_USB=m
 CONFIG_CAN_ESD_USB2=m
<span class="gd">-# CONFIG_CAN_ETAS_ES58X is not set
</span><span class="gi">+CONFIG_CAN_ETAS_ES58X=m
</span> CONFIG_CAN_GS_USB=m
 CONFIG_CAN_KVASER_USB=m
 CONFIG_CAN_MCBA_USB=m
<span class="p">@@ -9716,8 +9717,6 @@</span>
 CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
 # CONFIG_DEBUG_INFO_DWARF4 is not set
 CONFIG_DEBUG_INFO_BTF=y
<span class="gd">-CONFIG_PAHOLE_HAS_SPLIT_BTF=y
-CONFIG_DEBUG_INFO_BTF_MODULES=y
</span> # CONFIG_GDB_SCRIPTS is not set
 CONFIG_FRAME_WARN=2048
 CONFIG_STRIP_ASM_SYMS=y
<span class="p">@@ -9747,6 +9746,8 @@</span>
 CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL=y
 # CONFIG_UBSAN is not set
 CONFIG_HAVE_ARCH_KCSAN=y
<span class="gi">+CONFIG_HAVE_KCSAN_COMPILER=y
+# CONFIG_KCSAN is not set
</span> # end of Generic Kernel Debugging Instruments
 
 CONFIG_DEBUG_KERNEL=y
</pre></table></code></div></div><p>Of all configuration options that were different in both versions, option <code class="language-plaintext highlighter-rouge">CONFIG_DEBUG_INFO_BTF_MODULES</code> was the most interesting to my case. If enabled, it added two members to <code class="language-plaintext highlighter-rouge">struct module</code>:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">module</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="cp">#ifdef CONFIG_DEBUG_INFO_BTF_MODULES
</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">btf_data_size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">btf_data</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Given the alignment requirements of amd64, the compiler would likely add 4 Byte of padding between the int and the void pointer, resulting in a size of 16 Byte for the two members. At that point I was fairly certain I had found the culprit for my issues. The only thing I did not know was why the option had been disabled.</p><p>I retraced my compilation steps to determine why the option was disabled. The option seemed to be magically turned off after executing <code class="language-plaintext highlighter-rouge">make oldconfig</code>. After digging a little in the documentation, I found the reason: I was missing the <code class="language-plaintext highlighter-rouge">pahole</code> tool in my PATH. The Makefile automatically disabled the option if <code class="language-plaintext highlighter-rouge">pahole</code> was not found.</p><p>I installed the <code class="language-plaintext highlighter-rouge">dwarves</code> package in Kali, recompiled the kernel module, and called <code class="language-plaintext highlighter-rouge">insmod</code> to insert the module into the kernel. And behold:</p><div class="language-console highlighter-rouge"><div class="code-header"> <span data-label-text="Console"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="gp">$</span><span class="w"> </span>lsmod | <span class="nb">grep </span>etas
<span class="go">etas_es58x             53248  0
usbcore               331776  1 etas_es58x
can_dev                40960  1 etas_es58x
crc16                  16384  2 etas_es58x,ext4
</span></pre></table></code></div></div><p>The module was happy and alive.</p><h2 id="takeaway-message"><span class="mr-2">Takeaway Message</span><a href="#takeaway-message" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>When compiling a kernel module: always make sure that the configuration file doesn’t change while you’re not looking. This scenario wasn’t something I was aware of until now. And frankly, I do not consider it to be good design. Of course I don’t have the entire picture, but I believe a missing dependency should cause a build to fail fast, not produce incompatible artifacts.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/linux/'>Linux</a>, <a href='/categories/kernel/'>Kernel</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/linux/" class="post-tag no-text-decoration" >Linux</a> <a href="/tags/kernel/" class="post-tag no-text-decoration" >Kernel</a> <a href="/tags/qemu/" class="post-tag no-text-decoration" >QEMU</a> <a href="/tags/debugging/" class="post-tag no-text-decoration" >Debugging</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Debugging Linux Module Loading with QEMU - RAndom Notes on Tech&amp;url=https://lumagi.github.io/posts/compiling-intree-linux-modules/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Debugging Linux Module Loading with QEMU - RAndom Notes on Tech&amp;u=https://lumagi.github.io/posts/compiling-intree-linux-modules/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://lumagi.github.io/posts/compiling-intree-linux-modules/&amp;text=Debugging Linux Module Loading with QEMU - RAndom Notes on Tech" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/imx6-nand-flash/">Decoding raw i.MX6 NAND flash images</a><li><a href="/posts/Device-ID-support-in-Linux/">PCAN Device ID Support in Linux Kernel</a><li><a href="/posts/finding-arm-firmware-base-with-literal-pools/">Determining ARM firmware base addresses</a><li><a href="/posts/compiling-intree-linux-modules/">Debugging Linux Module Loading with QEMU</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/arm/">ARM</a> <a class="post-tag" href="/tags/bch/">BCH</a> <a class="post-tag" href="/tags/can/">CAN</a> <a class="post-tag" href="/tags/debugging/">Debugging</a> <a class="post-tag" href="/tags/firmware/">firmware</a> <a class="post-tag" href="/tags/flash/">Flash</a> <a class="post-tag" href="/tags/i-mx6/">i.MX6</a> <a class="post-tag" href="/tags/kernel/">Kernel</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/literal-pool/">literal pool</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Device-ID-support-in-Linux/"><div class="card-body"> <em class="timeago small" data-ts="1692007680" > 2023-08-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PCAN Device ID Support in Linux Kernel</h3><div class="text-muted small"><p> When building a test setup with multiple CAN controllers, it is crucial to ensure persistent device names, no matter boot or enumeration order. The PCAN USB-FD devices by Peak do not export a USB s...</p></div></div></a></div><div class="card"> <a href="/posts/imx6-nand-flash/"><div class="card-body"> <em class="timeago small" data-ts="1761499260" > 2025-10-26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Decoding raw i.MX6 NAND flash images</h3><div class="text-muted small"><p> I was recently working with a PCB featuring an i.MX6 SoC and a raw NAND flash chip. The SoC was running a u-boot and an embedded Linux off of the NAND flash chip. Since the debug port was properly ...</p></div></div></a></div><div class="card"> <a href="/posts/finding-arm-firmware-base-with-literal-pools/"><div class="card-body"> <em class="timeago small" data-ts="1650046080" > 2022-04-15 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Determining ARM firmware base addresses</h3><div class="text-muted small"><p> A common problem when reversing a firmware blob is to determine the correct offset at which to place the firmware file in memory. Recently, while doing some research into possible solutions, I came...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></span> <a href="/posts/finding-arm-firmware-base-with-literal-pools/" class="btn btn-outline-primary" prompt="Newer"><p>Determining ARM firmware base addresses</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/lumagi">Lukas Magel</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/arm/">ARM</a> <a class="post-tag" href="/tags/bch/">BCH</a> <a class="post-tag" href="/tags/can/">CAN</a> <a class="post-tag" href="/tags/debugging/">Debugging</a> <a class="post-tag" href="/tags/firmware/">firmware</a> <a class="post-tag" href="/tags/flash/">Flash</a> <a class="post-tag" href="/tags/i-mx6/">i.MX6</a> <a class="post-tag" href="/tags/kernel/">Kernel</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/literal-pool/">literal pool</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
