<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Decoding raw i.MX6 NAND flash images" /><meta property="og:locale" content="en" /><meta name="description" content="I was recently working with a PCB featuring an i.MX6 SoC and a raw NAND flash chip. The SoC was running a u-boot and an embedded Linux off of the NAND flash chip. Since the debug port was properly locked, I wanted to take a look at the embedded u-boot and Linux. I decided to desolder and dump the flash chip. This post documents how the i.MX6 stores user data on an external NAND flash and how this user data can be manually extracted while correcting bit errors." /><meta property="og:description" content="I was recently working with a PCB featuring an i.MX6 SoC and a raw NAND flash chip. The SoC was running a u-boot and an embedded Linux off of the NAND flash chip. Since the debug port was properly locked, I wanted to take a look at the embedded u-boot and Linux. I decided to desolder and dump the flash chip. This post documents how the i.MX6 stores user data on an external NAND flash and how this user data can be manually extracted while correcting bit errors." /><link rel="canonical" href="https://lumagi.github.io/posts/imx6-nand-flash/" /><meta property="og:url" content="https://lumagi.github.io/posts/imx6-nand-flash/" /><meta property="og:site_name" content="RAndom Notes on Tech" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-10-26T18:21:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Decoding raw i.MX6 NAND flash images" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-12-28T19:20:38+01:00","datePublished":"2025-10-26T18:21:00+01:00","description":"I was recently working with a PCB featuring an i.MX6 SoC and a raw NAND flash chip. The SoC was running a u-boot and an embedded Linux off of the NAND flash chip. Since the debug port was properly locked, I wanted to take a look at the embedded u-boot and Linux. I decided to desolder and dump the flash chip. This post documents how the i.MX6 stores user data on an external NAND flash and how this user data can be manually extracted while correcting bit errors.","headline":"Decoding raw i.MX6 NAND flash images","mainEntityOfPage":{"@type":"WebPage","@id":"https://lumagi.github.io/posts/imx6-nand-flash/"},"url":"https://lumagi.github.io/posts/imx6-nand-flash/"}</script><title>Decoding raw i.MX6 NAND flash images | RAndom Notes on Tech</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="RAndom Notes on Tech"><meta name="application-name" content="RAndom Notes on Tech"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">RAndom Notes on Tech</a></div><div class="site-subtitle font-italic">Random pieces of wisdom</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/lumagi" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Decoding raw i.MX6 NAND flash images</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Decoding raw i.MX6 NAND flash images</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/lumagi">Lukas Magel</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1761499260" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2025-10-26 </em> </span> <span> Updated <em class="timeago" data-ts="1766946038" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2025-12-28 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2670 words"> <em>14 min</em> read</span></div></div></div><div class="post-content"><p>I was recently working with a PCB featuring an i.MX6 SoC and a raw NAND flash chip. The SoC was running a u-boot and an embedded Linux off of the NAND flash chip. Since the debug port was properly locked, I wanted to take a look at the embedded u-boot and Linux. I decided to desolder and dump the flash chip. This post documents how the i.MX6 stores user data on an external NAND flash and how this user data can be manually extracted while correcting bit errors.</p><h2 id="nand-flash-memory"><span class="mr-2">NAND Flash Memory</span><a href="#nand-flash-memory" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The NAND flash memory I was working with supported the <a href="https://onfi.org/files/onfi_1_0_gold.pdf">ONFI specification 1.0</a>. I followed <a href="https://colinoflynn.com/2024/04/dumping-parallel-nand-with-glasgow/">the post by Colin O’Flynn</a> to solder wires to the BGA pads of the NAND flash. I used enameled wires and taped down each row after the other. I only soldered a single VCC and VDD pad, which turned out to be okay. All in all, I soldered the following connections:</p><div class="table-wrapper"><table><thead><tr><th>Pin Type<th>Description<tbody><tr><td>VCC<td>3V power, I only soldered a single pad<tr><td>VDD<td>Ground, I only soldered a single pad<tr><td>IO0 - IO7<td>8 bit I/O lines<tr><td>CE#<td>Chip Enable (Active Low)<tr><td>RE#<td>Read Enable (Active Low)<tr><td>WE#<td>Write Enable (Active Low)<tr><td>CLE<td>Command Latch Enable<tr><td>ALE<td>Address Latch Enable<tr><td>WP#<td>Write Protect (Active Low)<tr><td>R/B#<td>Busy signal from NAND, Open Drain</table></div><p>The <code class="language-plaintext highlighter-rouge">R/B#</code> signal requires a dedicated pull-up resistor since it is an open-drain signal. I didn’t solder the protection pin since the NAND flash has an internal pull-down resistor. The resistor unprotects the chip by default.</p><p>I used the ONFI applet of the <a href="https://glasgow-embedded.org/">Glasgow Interface Explorer</a> to communicate with the NAND flash. It was very impressive to see the ONFI applet work its magic right out of the box. Conveniently, the Glasgow applet directly dumped the flash characteristics contained in the Parameter Page (see chapter 5.4.1 of the ONFI specificaiton).</p><h3 id="flash-parameters"><span class="mr-2">Flash Parameters</span><a href="#flash-parameters" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The flash memory had the following characteristics:</p><div class="table-wrapper"><table><thead><tr><th>Parameter<th>Value<tbody><tr><td>Bytes per page<td>2048<tr><td>Spare bytes per page<td>64<tr><td>Pages per erase block<td>64<tr><td>Number of logical units<td>1<tr><td>Number of block ins a logical unit<td>4096<tr><td>Number of bits ECC correctability<td>4</table></div><p>The last parameter defines the required ECC strength. According to the specification, the host or flash controller must be able to identify and correct this many bit errors per 512 byte of user data. In our case, the ECC must be strong enough to identify and correct up to four bit flips per 512 byte of data. The specification does not say what ECC mechanism must be used or how this data should be organized within a flash page.</p><p>To me, this was unexpected. Literature or Wikipedia mention the spare area to be specific for ECC or manufacturing information. I simply assumed that this ECC information must then go into the spare area since that was its purpose, right? It turned out that at least in my case, there was no logical distinction between the two. According to the flash memory documentation, flash pages are always written or dumped with the full 2112 bytes. The flash memory page has this extra capacity for correction information, but how or where this information is stored within the page is of no interest to the flash memory. It provides this extra data per page as a convenience to the host, which must define its purpose.</p><p>In my scenario, the i.MX6 was acting as the host or flash controller. It also handled the page as a contiguous region of memory.</p><h3 id="dumping-the-flash"><span class="mr-2">Dumping the flash</span><a href="#dumping-the-flash" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The Glasgow applet worked right out of the box, and I was able to dump the memory successfully. The applet offers you the option of separating the regular area and spare area of the flash pages into separate files. Although this first sounded like a good idea, I later noticed that the flash controller did not make any distinction between the two. It treated the flash page as a contiguous region of 2112 bytes, so dumping them interleaved was the right choice.</p><p>As Colin described in his blog, I dumped the memory multiple times to work out any potential bit flips by means of majority voting. I expected my soldered enameled wires to introduce quite a bit of noise and transmission errors. And indeed, after dumping the memory twice and comparing the two dumps, I noticed a few bit errors. Compared to the size of the memory, there were only few, but they were present. Since I first assumed these bit errors to have been caused by interference, I pulled more dumps and wrote a little Python script to work out the errors by means of majority voting. However, the bit errors always occurred at the same locations in the dump and had a rather constant probability of occurring. Sometimes, this probability was almost 50/50, so there was no way to determine the proper value of a bit by pulling more dumps. And even if the bit was more likely to flip one way, there was no easy way of knowing if that was the correct value. In summary, it looked like these bit flips were not produced by the solder setup but by actual errors in the NAND flash chip.</p><p>To better understand the contents of the dump, I ran binwalk across the file. It looked like large portions of the dump were compressed or even encrypted. Under these circumstances, even a single bit error could prevent a successful decoding. I needed to better understand the format of the flash contents and potentially correct bit errors to be able to successfully extract the data.</p><h2 id="flash-controller"><span class="mr-2">Flash Controller</span><a href="#flash-controller" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>In comparison to NOR flash memory, a NAND flash memory requires more intensive care to be working reliably. This is most notably the handling of bad blocks and the transparent application of ECC to detect and correct bit flips in the data. As I was already able to experience while dumping the data from the memory, bit flips do occur during regular operation and need to be handled.</p><p>In my case, it was the job of the i.MX6 to take care of these tasks. The i.MX6 features a General Purpose Media Interface (GPMI) that operates as a flash controller. The GPMI uses the BCH accelerator of the chip to implement error correcting codes. The following sections of the reference manual are of interest (the manual can be found with a Google search):</p><ul><li>Chapter 17: 40-Bit Correcting ECC Accelerator (BCH)<ul><li>17.2.2: Flash Page Layout<li>17.6.8: Hardware BCH ECC Flash 0 Layout 0 Register<li>17.6.9: Hardware BCH ECC Flash 0 Layout 1 Register</ul><li>Chapter 8: System Boot<ul><li>8.5.2.5: Back block handling in ROM<li>8.5.2.8: Typical NAND Page Organization</ul></ul><p>The flash controller provides a convenient error-free abstraction of the raw flash memory. It does so by multiplexing the user data with additionall error-correcting information and metadata.</p><h3 id="flash-layout"><span class="mr-2">Flash Layout</span><a href="#flash-layout" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The flash controller supports different flash page layouts depending on the page size and the ECC needs of the flash chip. In general, the complete flash page (regular and spare area) is divided into blocks. In my case, the user data on the page was split into four block of 512 byte. After each data block comes an ECC block that carries the correcting code for the preceding data block. Before the first block comes a block of metadata. This metadata is specific to the i.MX flash controller. In contrast to <code class="language-plaintext highlighter-rouge">ECC1</code> to <code class="language-plaintext highlighter-rouge">ECCN</code>, <code class="language-plaintext highlighter-rouge">ECC0</code> also covers the metadata block.</p><p>The following image shows the general layout of a flash page:</p><p><img data-src="/assets/images/2025_11_imx_flash_page.svg" alt="Flash Layout" width="100%" data-proofer-ignore></p><p>The size of the metadata, the size of the blocks, and the applied BCH strength are configurable (see the mentioned registers above). My first assumption was that the configuration of these registers is done statically by u-boot during boot. I poked around in the u-boot code for a little while until I found the relevant sections.</p><h3 id="u-boot-imx-flash-configuration"><span class="mr-2">u-boot i.MX Flash Configuration</span><a href="#u-boot-imx-flash-configuration" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>I was surprised to see that the configuration of the i.MX6 flash controller in u-boot is not done statically in the sense that a fixed static configuration is applied. Instead, the controller is dynamically configured depending on the characteristics of the chip. When booting, u-boot automatically configures the flash controller according to these flash parameters. The flash parameters are read from the flash chip and stored in <a href="https://github.com/u-boot/u-boot/blob/56cac250b0839ddbad1311d3ca4231f532b5aadf/include/linux/mtd/rawnand.h#L914">struct nand_chip</a>. The two most important values are <code class="language-plaintext highlighter-rouge">ecc_strength_ds</code> and <code class="language-plaintext highlighter-rouge">ecc_step_ds</code>, which are the required ECC strength and the number of bytes after which an ECC is required. As mentioned above, in my case this was 4 bits of ECC correctability per 512 byte of data.</p><p>The main function responsible for determining the configuration is called <a href="https://github.com/u-boot/u-boot/blob/56cac250b0839ddbad1311d3ca4231f532b5aadf/drivers/mtd/nand/raw/mxs_nand.c#L1125">mxs_nand_set_geometry</a>. Based on the known characteristics of the flash chip, I concluded that it branches to <a href="https://github.com/u-boot/u-boot/blob/56cac250b0839ddbad1311d3ca4231f532b5aadf/drivers/mtd/nand/raw/mxs_nand.c#L197">mxs_nand_legacy_calc_ecc_layout</a> for calculation of the ECC parameters. An extract of <code class="language-plaintext highlighter-rouge">mxs_nand_legacy_calc_ecc_layout</code> is shown below:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mxs_nand_legacy_calc_ecc_layout</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_geometry</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
    <span class="cm">/* The default for the length of Galois Field. */</span>
    <span class="n">geo</span><span class="o">-&gt;</span><span class="n">gf_len</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>

    <span class="cm">/* The default for chunk size. */</span>
    <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk0_size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
    <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunkn_size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>

    <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>

    <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_count</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">/</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunkn_size</span><span class="p">;</span>

    <span class="cm">/*
     * Determine the ECC layout with the formula:
     *	ECC bits per chunk = (total page spare data bits) /
     *		(bits per ECC level) / (chunks per page)
     * where:
     *	total page spare data bits =
     *		(page oob size - meta data size) * (bits per byte)
     */</span>
    <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_strength</span> <span class="o">=</span> <span class="p">((</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span> <span class="o">-</span> <span class="n">MXS_NAND_METADATA_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">gf_len</span> <span class="o">*</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_count</span><span class="p">);</span>

    <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_strength</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">round_down</span><span class="p">(</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_strength</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                <span class="n">nand_info</span><span class="o">-&gt;</span><span class="n">max_ecc_strength_supported</span><span class="p">);</span>

    <span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The function configures a block size of 512 bytes and Galois Field <code class="language-plaintext highlighter-rouge">GF(13)</code> for the BCH codes. The i.MX metadata field is always set to a length of <code class="language-plaintext highlighter-rouge">MXS_NAND_METADATA_SIZE = 10</code> bytes. With a flash page size of $2048 + 64 = 2112$, the code comes to the conclusion that four blocks fit into a page, meaning that <code class="language-plaintext highlighter-rouge">geo-&gt;ecc_chunk_count</code> is four. The only remaining unknown is the length of each <code class="language-plaintext highlighter-rouge">ECC</code> field. Instead of directly using what is required according to the flash parameters, the function determines which ECC strength is theoretically achievable based on the available space: the configuration stores four blocks of 512 byte in the page, which completely fills the regular page area. Out of the 64 byte of spare area only 54 byte can be used for ECC since we must account for the 10 byte of metadata. Consequently, each of the four blocks can be protected with 13 bytes of ECC. Since we’re using Galois field <code class="language-plaintext highlighter-rouge">GF(2^13)</code>, each bit of correctability requires 13 bits of redundancy. In this specific case, $13 \cdot 8 / 13 = 8$ bits of correctability are at maximum possible based on the available space.</p><p>After calculating the maximum possible ECC strength, the function checks if this strength satisfies the requirements mentioned in the flash parameter page. Here, the calculated correctability of 8 exceeds the requirement of 4 and is accepted by the function. Hence, we have the following parameters for the flash page protection:</p><div class="table-wrapper"><table><thead><tr><th>Parameter<th>Value<tbody><tr><td>Block size<td>512 byte<tr><td>Metadata size<td>10 byte<tr><td>BCH Galois Field<td>13<tr><td>BCH level<td>BCH8<tr><td>ECC size per block<td>13 byte</table></div><p>If we fully calculate this through, we have $4 \cdot 512 + 4 \cdot 13 + 10 = 2110$ bytes required, which means that the two last bytes in the flash page are unused.</p><h2 id="flash-dump-data-reconstruction-in-python"><span class="mr-2">Flash Dump Data Reconstruction in Python</span><a href="#flash-dump-data-reconstruction-in-python" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Now that the flash page layout was known, the last step was to make use of the ECC fields in the flash pages to correct the bit errors in the dump. This basically meant reimplementing the ECC correction algorithm. After doing a bit of testing, I found that the following steps needed to be implemented:</p><ul><li>Using the BCH ECC to correct bit errors in the blocks of each page.<li>Swapping the bad block marker from address 0x800 back to page address 0x0.<li>Stripping the $4 \cdot 13$ bytes of ECC and the two spare bytes at the end of the page to retrieve 2048 byte of user data.</ul><h3 id="bit-correction-with-bch"><span class="mr-2">Bit correction with BCH</span><a href="#bit-correction-with-bch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>This task is a brilliant example of why I love Python as a tooling language: there already exists a neat Python library called <a href="https://github.com/jkent/python-bchlib">python-bchlib</a> that implements the BCH algorithm.</p><p>The following code snippet performs the ECC correction in place. A bytearray containing a single flash page is passed into the function and modified in place.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">bchlib</span> <span class="kn">import</span> <span class="n">BCH</span>

<span class="n">USER_PAGE_LEN</span> <span class="o">=</span> <span class="mi">2048</span>
<span class="n">PAGE_LEN</span> <span class="o">=</span> <span class="n">USER_PAGE_LEN</span> <span class="o">+</span> <span class="mi">64</span>
<span class="n">META_LEN</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">BLOCK_LEN</span> <span class="o">=</span> <span class="mi">512</span>
<span class="n">ECC_LEN</span> <span class="o">=</span> <span class="mi">13</span>
<span class="n">EMPTY_ECC</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"</span><span class="se">\xff</span><span class="s">"</span> <span class="o">*</span> <span class="n">ECC_LEN</span>

<span class="k">def</span> <span class="nf">run_page_ecc_in_place</span><span class="p">(</span><span class="n">page</span><span class="p">:</span> <span class="nb">bytearray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PAGE_LEN</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s">"Supplied page data does not have required length: </span><span class="si">{</span><span class="n">PAGE_LEN</span><span class="si">}</span><span class="s">"</span>
        <span class="p">)</span>

    <span class="n">bch</span> <span class="o">=</span> <span class="n">BCH</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">swap_bits</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">block_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">block_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">block_len</span> <span class="o">=</span> <span class="n">BLOCK_LEN</span> <span class="o">+</span> <span class="n">META_LEN</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">block_len</span> <span class="o">=</span> <span class="n">BLOCK_LEN</span>

        <span class="n">block_w_ecc</span> <span class="o">=</span> <span class="n">page</span><span class="p">[</span><span class="n">offset</span> <span class="p">:</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">block_len</span> <span class="o">+</span> <span class="n">ECC_LEN</span><span class="p">]</span>
        <span class="n">block_data</span> <span class="o">=</span> <span class="n">block_w_ecc</span><span class="p">[:</span><span class="n">block_len</span><span class="p">]</span>
        <span class="n">block_ecc</span> <span class="o">=</span> <span class="n">block_w_ecc</span><span class="p">[</span><span class="n">block_len</span><span class="p">:]</span>

        <span class="n">expected_ecc</span> <span class="o">=</span> <span class="n">bch</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">block_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">block_ecc</span> <span class="o">!=</span> <span class="n">EMPTY_ECC</span> <span class="ow">and</span> <span class="n">block_ecc</span> <span class="o">!=</span> <span class="n">expected_ecc</span><span class="p">:</span>
            <span class="c1"># The correction is done in place
</span>            <span class="n">bch</span><span class="p">.</span><span class="n">correct</span><span class="p">(</span><span class="n">block_data</span><span class="p">,</span> <span class="n">block_ecc</span><span class="p">)</span>

        <span class="n">offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_w_ecc</span><span class="p">)</span>

</pre></table></code></div></div><h3 id="bad-block-marker-swapping"><span class="mr-2">Bad Block Marker Swapping</span><a href="#bad-block-marker-swapping" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>After correcting the bit errors, I noticed that the dump data still contained spurious 0xFF bytes in an otherwise completely empty flash page. These bytes were always located at offset 0x800. Chapter 8.5.2.5 explains that the single byte at this offset is the original bad block marker written there by the flash manufacturer. The motivation for this behavior is also documented in a <a href="https://community.nxp.com/pwmxy87654/attachments/pwmxy87654/imx-processors/134096/2/AN_MX_NAND_BAD_BLOCK.pdf">legacy document by freescale</a>. Due to the interleaved approach of putting the ECC in between the 512 byte data blocks, the bad block marker at offset 0x800 would be located inside the last data block. To avoid this, the flash controller stores the marker in the metadata field which is kept at the beginning of the page. However, when the page is written to the NAND flash, the bad block marker byte is again swapped back to 0x800 to maintain its original position. The data byte contained at offset 0x800 is placed at offset 0x0. The swapping occurs before the ECC for the page blocks is calculated.</p><p>We must invert this operation when we manually decode the page. Since, during a write, the ECC is applied after the swap, we must first correct the ECC and then swap back.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">BB_MARKER_OFFSET</span> <span class="o">=</span> <span class="mh">0x800</span>


<span class="k">def</span> <span class="nf">swap_bb_marker_in_place</span><span class="p">(</span><span class="n">page</span><span class="p">:</span> <span class="nb">bytearray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">page</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">[</span><span class="n">BB_MARKER_OFFSET</span><span class="p">]</span>
    <span class="n">page</span><span class="p">[</span><span class="n">BB_MARKER_OFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
</pre></table></code></div></div><h3 id="stripping-the-metadata-and-ecc"><span class="mr-2">Stripping the metadata and ECC</span><a href="#stripping-the-metadata-and-ecc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The last step is to strip the unneeded metadata and ECC information to retrieve the 2048 byte of user data stored in the page:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">strip_meta_and_ecc</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">bytearray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytearray</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PAGE_LEN</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s">"Supplied page data does not have required length: </span><span class="si">{</span><span class="n">PAGE_LEN</span><span class="si">}</span><span class="s">"</span>
        <span class="p">)</span>

    <span class="n">src_wo_meta</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">META_LEN</span><span class="p">:]</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">USER_PAGE_LEN</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">blk_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">src_start</span> <span class="o">=</span> <span class="n">blk_idx</span> <span class="o">*</span> <span class="p">(</span><span class="n">BLOCK_LEN</span> <span class="o">+</span> <span class="n">ECC_LEN</span><span class="p">)</span>
        <span class="n">data_block</span> <span class="o">=</span> <span class="n">src_wo_meta</span><span class="p">[</span><span class="n">src_start</span> <span class="p">:</span> <span class="n">src_start</span> <span class="o">+</span> <span class="n">BLOCK_LEN</span><span class="p">]</span>

        <span class="n">dst_start</span> <span class="o">=</span> <span class="n">blk_idx</span> <span class="o">*</span> <span class="n">BLOCK_LEN</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">dst_start</span> <span class="p">:</span> <span class="n">dst_start</span> <span class="o">+</span> <span class="n">BLOCK_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_block</span>

    <span class="k">return</span> <span class="n">dst</span>
</pre></table></code></div></div><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>With the code snippets above, I was able to fully recover the data and correct any bit errors. I was even able to decompress the compressed portion of the stored data without any issues.</p><p>It was very interesting to see and understand how the data is physically stored and protected in a NAND flash chip. I hope this information can be helpful to others that must go through the same process. Although NXP partially documents its implementation in the reference manual, there is no public implementation of the algorithm. And since all the mechanisms mentioned here are solely applied in hardware, there is no easy way to reverse engineer the implementation.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/embedded/'>Embedded</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/nand/" class="post-tag no-text-decoration" >NAND</a> <a href="/tags/flash/" class="post-tag no-text-decoration" >Flash</a> <a href="/tags/i-mx6/" class="post-tag no-text-decoration" >i.MX6</a> <a href="/tags/bch/" class="post-tag no-text-decoration" >BCH</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Decoding raw i.MX6 NAND flash images - RAndom Notes on Tech&amp;url=https://lumagi.github.io/posts/imx6-nand-flash/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Decoding raw i.MX6 NAND flash images - RAndom Notes on Tech&amp;u=https://lumagi.github.io/posts/imx6-nand-flash/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://lumagi.github.io/posts/imx6-nand-flash/&amp;text=Decoding raw i.MX6 NAND flash images - RAndom Notes on Tech" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/imx6-nand-flash/">Decoding raw i.MX6 NAND flash images</a><li><a href="/posts/Device-ID-support-in-Linux/">PCAN Device ID Support in Linux Kernel</a><li><a href="/posts/finding-arm-firmware-base-with-literal-pools/">Determining ARM firmware base addresses</a><li><a href="/posts/compiling-intree-linux-modules/">Debugging Linux Module Loading with QEMU</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/arm/">ARM</a> <a class="post-tag" href="/tags/bch/">BCH</a> <a class="post-tag" href="/tags/can/">CAN</a> <a class="post-tag" href="/tags/debugging/">Debugging</a> <a class="post-tag" href="/tags/firmware/">firmware</a> <a class="post-tag" href="/tags/flash/">Flash</a> <a class="post-tag" href="/tags/i-mx6/">i.MX6</a> <a class="post-tag" href="/tags/kernel/">Kernel</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/literal-pool/">literal pool</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Device-ID-support-in-Linux/"><div class="card-body"> <em class="timeago small" data-ts="1692007680" > 2023-08-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PCAN Device ID Support in Linux Kernel</h3><div class="text-muted small"><p> When building a test setup with multiple CAN controllers, it is crucial to ensure persistent device names, no matter boot or enumeration order. The PCAN USB-FD devices by Peak do not export a USB s...</p></div></div></a></div><div class="card"> <a href="/posts/finding-arm-firmware-base-with-literal-pools/"><div class="card-body"> <em class="timeago small" data-ts="1650046080" > 2022-04-15 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Determining ARM firmware base addresses</h3><div class="text-muted small"><p> A common problem when reversing a firmware blob is to determine the correct offset at which to place the firmware file in memory. Recently, while doing some research into possible solutions, I came...</p></div></div></a></div><div class="card"> <a href="/posts/compiling-intree-linux-modules/"><div class="card-body"> <em class="timeago small" data-ts="1639243271" > 2021-12-11 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Debugging Linux Module Loading with QEMU</h3><div class="text-muted small"><p> My company uses the ETAS ES582.1 CAN adapters to interface with a CAN bus. Since recently, the kernel has mainline support for these devices (the etas_es58x driver). However, my work operating sy...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Device-ID-support-in-Linux/" class="btn btn-outline-primary" prompt="Older"><p>PCAN Device ID Support in Linux Kernel</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/lumagi">Lukas Magel</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/arm/">ARM</a> <a class="post-tag" href="/tags/bch/">BCH</a> <a class="post-tag" href="/tags/can/">CAN</a> <a class="post-tag" href="/tags/debugging/">Debugging</a> <a class="post-tag" href="/tags/firmware/">firmware</a> <a class="post-tag" href="/tags/flash/">Flash</a> <a class="post-tag" href="/tags/i-mx6/">i.MX6</a> <a class="post-tag" href="/tags/kernel/">Kernel</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/literal-pool/">literal pool</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
