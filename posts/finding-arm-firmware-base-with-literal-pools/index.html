<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Determining ARM firmware base addresses" /><meta property="og:locale" content="en" /><meta name="description" content="A common problem when reversing a firmware blob is to determine the correct offset at which to place the firmware file in memory. Recently, while doing some research into possible solutions, I came across a paper by Zhu et al. The paper proposes an approach that exploits the addresses found in 32bit ARM literal pools to determine the correct firmware offset. I was able to successfully implement and use their approach to determine the offset of two firmware blobs. In this post, I present my implementation: First, I give a quick overview of ARM literal pools. I explain the algorithm concept and provide a detailed analysis of my implementation." /><meta property="og:description" content="A common problem when reversing a firmware blob is to determine the correct offset at which to place the firmware file in memory. Recently, while doing some research into possible solutions, I came across a paper by Zhu et al. The paper proposes an approach that exploits the addresses found in 32bit ARM literal pools to determine the correct firmware offset. I was able to successfully implement and use their approach to determine the offset of two firmware blobs. In this post, I present my implementation: First, I give a quick overview of ARM literal pools. I explain the algorithm concept and provide a detailed analysis of my implementation." /><link rel="canonical" href="https://lumagi.github.io/posts/finding-arm-firmware-base-with-literal-pools/" /><meta property="og:url" content="https://lumagi.github.io/posts/finding-arm-firmware-base-with-literal-pools/" /><meta property="og:site_name" content="RAndom Notes on Tech" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-15T20:08:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Determining ARM firmware base addresses" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-30T08:26:34+02:00","datePublished":"2022-04-15T20:08:00+02:00","description":"A common problem when reversing a firmware blob is to determine the correct offset at which to place the firmware file in memory. Recently, while doing some research into possible solutions, I came across a paper by Zhu et al. The paper proposes an approach that exploits the addresses found in 32bit ARM literal pools to determine the correct firmware offset. I was able to successfully implement and use their approach to determine the offset of two firmware blobs. In this post, I present my implementation: First, I give a quick overview of ARM literal pools. I explain the algorithm concept and provide a detailed analysis of my implementation.","headline":"Determining ARM firmware base addresses","mainEntityOfPage":{"@type":"WebPage","@id":"https://lumagi.github.io/posts/finding-arm-firmware-base-with-literal-pools/"},"url":"https://lumagi.github.io/posts/finding-arm-firmware-base-with-literal-pools/"}</script><title>Determining ARM firmware base addresses | RAndom Notes on Tech</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="RAndom Notes on Tech"><meta name="application-name" content="RAndom Notes on Tech"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">RAndom Notes on Tech</a></div><div class="site-subtitle font-italic">Random pieces of wisdom</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/lumagi" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Determining ARM firmware base addresses</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Determining ARM firmware base addresses</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/lumagi">Lukas Magel</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1650046080" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-15 </em> </span> <span> Updated <em class="timeago" data-ts="1664519194" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-09-30 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3142 words"> <em>17 min</em> read</span></div></div></div><div class="post-content"><p><a href="https://reverseengineering.stackexchange.com/questions/30157/arm-understanding-a-base-address-when-reversing-firmware">A common problem</a> when reversing a firmware blob is to determine the correct offset at which to place the firmware file in memory. Recently, while doing some research into possible solutions, I came across a paper by <a href="https://www.sciencedirect.com/science/article/abs/pii/S1742287616000037">Zhu et al.</a> The paper proposes an approach that exploits the addresses found in 32bit ARM literal pools to determine the correct firmware offset. I was able to successfully implement and use their approach to determine the offset of two firmware blobs. In this post, I present my implementation: First, I give a quick overview of ARM literal pools. I explain the algorithm concept and provide a detailed analysis of my implementation.</p><h2 id="arm-literal-pools"><span class="mr-2">ARM Literal Pools</span><a href="#arm-literal-pools" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Instructions in 32bit ARM can have a length of two or four bytes. This design choice poses some restrictions on how an address can be loaded into a register since a full 32bit address is too long to fit into a single instruction. The following code snippet provides an example of such a scenario:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">char</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">_start</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="s">"Bar Baz Buzz</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="s">"Bar Baz Buzz 22</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In order to call function <code class="language-plaintext highlighter-rouge">foo</code>, the compiler must place the address to the string literals in register <code class="language-plaintext highlighter-rouge">r0</code>. Since the strings are stored in the <code class="language-plaintext highlighter-rouge">.rodata</code> section of the application, they are potentially located out of range for PC-relative addressing. Hence, the compiler generates the following code:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>00008028 &lt;_start&gt;:
    ...
    8034:       e59f0038        ldr     r0, [pc, #56]   ; 8074 &lt;_start+0x4c&gt;
    8038:       ebfffff0        bl      8000 &lt;foo&gt;
    803c:       e1a03000        mov     r3, r0
    8040:       e54b3005        strb    r3, [fp, #-5]
    8044:       e59f002c        ldr     r0, [pc, #44]   ; 8078 &lt;_start+0x50&gt;
    8048:       ebffffec        bl      8000 &lt;foo&gt;
    ...
    8074:       0000807c        .word   0x0000807c
    8078:       0000808c        .word   0x0000808c
</pre></table></code></div></div><p>It places the absolute addresses to the two string literals at the end of the function and uses a PC-relative load instruction to fetch the values from the function trailer into register <code class="language-plaintext highlighter-rouge">r0</code> before calling <code class="language-plaintext highlighter-rouge">foo</code>. A collection of such addresses at the end of a function is called a literal pool. For functions that access various different objects in the <code class="language-plaintext highlighter-rouge">.data</code> or <code class="language-plaintext highlighter-rouge">.rodata</code> sections, these pools can grow to a significant size. They need not only point to strings, the compiler also generates entries for other things like long program jumps, global variables or even C++ vtables.</p><p>Since these literal pools use absolute addresses, they can potentially disclose or narrow down the base address of the firmware blob. In the following section, I describe how this can be accomplished by identifying and linking pool addresses to string literals.</p><h2 id="algorithm-concept"><span class="mr-2">Algorithm Concept</span><a href="#algorithm-concept" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>For our scenario, we assume to have been given a binary firmware blob that runs on a 32bit ARM chip and operates on string literals, meaning that it accesses string constants in the <code class="language-plaintext highlighter-rouge">.rodata</code> section. We don’t know at which address the firmware is loaded into memory. This makes firmware analysis more complicated because code jumps, variables or strings that rely on absolute addressing cannot be resolved if the firmware is placed at an incorrect location. Hence, the goal of this algorithm is to determine the absolute address at which the firmware image is supposed to be loaded into memory.</p><h3 id="prerequisites"><span class="mr-2">Prerequisites</span><a href="#prerequisites" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The algorithm has two prerequisites that must be extracted from the firmware image beforehand:</p><ul><li>The offsets to all string literals that can be identified in the firmware image<li>The addresses contained in all identifyable literal pools</ul><p>Although I list these steps as prerequisite, identifying the literal pool addresses can be considered an important step in the algorithm. The results of these two steps do not necessarily need to be perfect, i.e. can contain false positives, as long as the amount of identified literal pools and string constants is sufficiently high.</p><h3 id="algorithm-description"><span class="mr-2">Algorithm Description</span><a href="#algorithm-description" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Since the compiler always creates literal pools for code that accesses string constants, we can assume that some of the literal pool addresses we identified in the last step must point to the string literals that we found. We can now try out different base addresses and determine the number of literal pool addresses that correctly link up with the identified string constants. The base address that maximizes this function can be considered the correct base address (given that we have correctly selected our candidate base addresses).</p><p>This algorithm turns our search into an optimization problem. The advantage of this is that we do not need to find all strings or all literal pools. As long as we find a sufficient number of samples, we can be sure that our algorithm will converge. However, it can also be considered somewhat of a brute-force method, and we need to be smart about what addresses we consider as possible load locations for the firmware. If we select an address range that is too broad, the algorithm will likely not terminate. Fortunately, the non-volatile memory of most embedded chips is rather small compared to the 32 bit address space. Additionally, we can assume the firmware addresses to be aligned to 0x4 or possibly even 0x10 boundaries to further narrow down the search space.</p><h2 id="algorithm-implementation"><span class="mr-2">Algorithm Implementation</span><a href="#algorithm-implementation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Given the theoretical description in the previous section, simply put, we need to do three things:</p><ul><li>Identify the string constants in the firmware image,<li>Identify ARM literal pools in the firmeware image,<li>Try out all possible base addresses to determine the one that maximizes the matches between literal pool addresses and string locations.</ul><p>I implemented each step as part of a Python script. I published the full script as a GitHub Gist <a href="https://gist.github.com/lumagi/28a479c7a41d466660e5a6a76038012c">here</a>. Below, I describe each step in greater detail.</p><h3 id="string-search"><span class="mr-2">String Search</span><a href="#string-search" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>I used the following function to find strings in the firmware. It does a simple regular expression search to determine string literals locations in the image.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">find_string_positions</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Find ASCII strings in the firmware blob and return the addresses

    The function uses a regular expression to find the addresses of valid ASCII strings in the firmware.
    If you set the align parameter to something other than None, make sure that the firmware blob is aligned to the
    same value.

    :param data: The firmware blob to search
    :param align: If set to a value other than None, all returned addresses are aligned to this value.
    :return: The addresses of valid strings in the firmware blob
    """</span>
    <span class="n">re_str</span> <span class="o">=</span> <span class="sa">br</span><span class="s">'[\w\s\/*:,;$%&amp;_-]{5,1000}'</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nb">compile</span><span class="p">(</span><span class="n">re_str</span><span class="p">)</span>

    <span class="n">str_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="n">start</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">regex</span><span class="p">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">align</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">str_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">str_pos</span> <span class="k">if</span> <span class="n">p</span> <span class="o">%</span> <span class="n">align</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">str_pos</span>
</pre></table></code></div></div><p>The function operates directly on the firmware blob and outputs all locations, i.e. offsets relative to the beginning of the file, that match the regular expression. The regular expression matches against all strings that consist of alphanumeric characters, spaces, and the list of special characters. This is not necessarily a very precise or exhaustive definition but appears to be sufficient for at least some cases. In order to avoid false positives, the function can optionally filter out all addresses that are not aligned on a four-byte boundary. Since the firmware runs on a 32bit ARM chip, we can assume all strings placed in the <code class="language-plaintext highlighter-rouge">.rodata</code> section by the compiler will have this alignment.</p><h3 id="literal-pool-search"><span class="mr-2">Literal Pool Search</span><a href="#literal-pool-search" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The second step is to locate literal pools in the firmware image. This step is based on the publication mentioned above but uses a simpler heuristic to accept or reject literal pool candidates. The search operates directly on the binary file and does not require any prior analysis to detect code blocks.</p><p>The search assumes that a literal pool consists of multiple entries. All entries in such a pool must point to a certain region in address space. This is a valid assumption to make since we know the chip and its address mapping. If the firmware is loaded directly from the memory-mapped internal or external flash of the chip, the literal pools must point there. And since the size of most flash banks is rather limited, the valid address range is likely rather small. Consequently, we can assume a candidate pool to be valid if all addresses contained in it point to our target memory region.</p><p>The algorithm uses a dynamically-sized window that is moved across the entire firmware image. With every iteration, the algorithm checks if all values inside the window can be interpreted as absolute addresses pointing into a certain address range. If that is the case, the region is assumed to be a literal pool and the window size is increased until the check fails. All addresses are then added to a buffer, and the window is reset and moved to the next position. Below, I list the complete function:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">find_address_pools</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">target_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">win_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">WIN_SIZE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">"""Find ARM 32 bit address pools in the firmware and return the contained addresses

    The function will only perform well if the target_range is narrow. Otherwise a lot of pools will be found.
    Also, the firmware blob must be word-aligned.

    :param data: The firmware blob to search for address pools
    :param target_range: The target address range that the addresses must point to.
    :param win_size: The minimum size that a pool must have
    :return: A list of unique addresses that were found in the pools
    """</span>
    <span class="n">data_arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pool_size</span> <span class="o">=</span> <span class="n">win_size</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">pool_size</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_arr</span><span class="p">):</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">data_arr</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span> <span class="o">+</span> <span class="n">pool_size</span><span class="p">]</span>
        <span class="n">elements_in_range</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">pool</span> <span class="o">&gt;=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pool</span> <span class="o">&lt;</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="p">.</span><span class="nb">all</span><span class="p">(</span><span class="n">elements_in_range</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pool_size</span> <span class="o">&gt;</span> <span class="n">win_size</span><span class="p">:</span>
                <span class="c1"># The last entry is not valid but we increased the pool size in the last iteration.
</span>                <span class="c1"># That means that the last iteration contained a valid pool.
</span>                <span class="c1"># Store the pool and reset the window
</span>                <span class="n">pos</span> <span class="o">+=</span> <span class="n">pool_size</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">candidates</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">pool</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Entries are not valid and we did not increase the window size in the last iteration
</span>                <span class="c1"># Move the window
</span>                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Reset the pool size to default
</span>            <span class="n">pool_size</span> <span class="o">=</span> <span class="n">win_size</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># All items are valid, increase the pool size
</span>            <span class="n">pool_size</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
</pre></table></code></div></div><p>The algorithm accepts the firmware image as binary blob, a target address range, and the minimum window size (which defaults to 3). The target address range parameter represents the range in address space that the values in a candidate literal pool must point to in order to be considered valid. In general, this will be the address range of the flash memory.</p><p>The algorithm first converts the binary firmware image into a numpy array of type uint32 with little endianess. Since all addresses inside a pool will be located on a 32 bit boundary, we can safely perform this conversion. The loop begins by placing the moving window at the beginning of the image. I then checks if all values inside the window are valid pool addresses, i.e. point into the target memory region. If that is the case, the window size is increased until the condition fails. All addresses in the pool are added to the result set and the window is reset to its minimum size and moved to the next position. This process is repeated until the window reaches the end of the image. The algorithm then returns a unique set of literal pool addresses as list.</p><h3 id="load-address-search"><span class="mr-2">Load Address Search</span><a href="#load-address-search" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The last step is an exhaustive search over all possible firmware base addresses to determine the base address that maximizes the number of matches between literal pool addresses and string locations. Again, we must carefully consider the number of possible base addresses to not overwhelm the algorithm. If we select an address region that is too broad, the algorithm will not terminate. However, normally the range of valid base addresses is limited by the size of the ROM or RAM of the chip. Additionally, we can safely assume that the base address must at least align to a 4 byte boundary. Below, I show the code that performs the search.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">count_matches_for_offsets</span><span class="p">(</span><span class="n">pool_addresses</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
                              <span class="n">str_offsets</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
                              <span class="n">candidate_load_addresses</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""For each offset in the search range, count how many str_offsets match up with
        the addr_pointers
    
    This function correlates the offsets of the strings that were found in the firmware
    to the target address pools. For each possible offset in offset_search_range, it
    calculates how many of the pool_addresses match up with the
    str_offsets + offset_search_range[i].

    :param pool_addresses: The addresses that are supposed to point to the strings found
        in the firmware
    :param str_offsets: The offsets of all strings found in the firmware, relative to the
        start of the file
    :param candidate_load_addresses: The range of possible firmware offsets to try
    :return: For each offset in fw_offset_range, the function returns the number of
        pool_addresses that match up with the corresponding adjusted str_offsets.
    """</span>
    <span class="n">matches_lst</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">candidate_load_addresses</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">candidate_load_addresses</span><span class="p">)):</span>
        <span class="n">cur_target_offsets</span> <span class="o">=</span> <span class="n">str_offsets</span> <span class="o">+</span> <span class="n">i</span>
        <span class="n">intersect</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">pool_addresses</span><span class="p">,</span> <span class="n">cur_target_offsets</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">matches_lst</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersect</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">matches_lst</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint64</span><span class="p">)</span>
</pre></table></code></div></div><p>The function is given the list of literal pool addresses and string offsets determined previously. Both are provided as numpy arrays for easier handling. Third, the function requires the list of firmware base addresses for which to calculate the number of matches.</p><p>For every possible base address, the function calculates the intersection of literal pool addresses and absolute string offsets. The intersection is equivalent to the number of address pool entries that correctly match up with a string. The function returns an 2D array that list for each load offset the number matched strings.</p><h3 id="putting-it-all-together"><span class="mr-2">Putting it all together</span><a href="#putting-it-all-together" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Lastly, I use the following code snippet with main function to put it all together. The window size is set to 3 and the word size is set to 4. The chip had an internal flash with an address range from <code class="language-plaintext highlighter-rouge">0x0</code> to <code class="language-plaintext highlighter-rouge">0x80000</code>. Hence, I configured the target range to fall within that part of address space. Lastly, I set a step size of <code class="language-plaintext highlighter-rouge">0x10</code>. This is an important hyperparameter, as it can lead to false results if set too big or cause the algorithm not to finish in time if set too small. In general, it shouldn’t need to be set to a value smaller than the word size of the system.</p><p>The main function itself chains together the functions explained above. It collects the string offsets and literal pool addresses. It converts the results into <code class="language-plaintext highlighter-rouge">numpy</code> arrays for easier handling. After calculating the match array, it determines the base address with the maximum number of matches and generates a plot for visualization.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="n">WIN_SIZE</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">WORD_SIZE</span> <span class="o">=</span> <span class="mi">4</span>

<span class="n">TARGET_RANGE</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x80000</span><span class="p">)</span>
<span class="n">STEP_SIZE</span> <span class="o">=</span> <span class="mh">0x10</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">fpath</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">firmware</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">time_pre</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">str_pos</span> <span class="o">=</span> <span class="n">find_string_positions</span><span class="p">(</span><span class="n">firmware</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">WORD_SIZE</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">str_pos</span><span class="p">)</span><span class="si">}</span><span class="s"> unique strings"</span><span class="p">)</span>

    <span class="n">pool_addresses</span> <span class="o">=</span> <span class="n">find_address_pools</span><span class="p">(</span><span class="n">firmware</span><span class="p">,</span> <span class="n">target_range</span><span class="o">=</span><span class="n">TARGET_RANGE</span><span class="p">,</span> <span class="n">win_size</span><span class="o">=</span><span class="n">WIN_SIZE</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pool_addresses</span><span class="p">)</span><span class="si">}</span><span class="s"> unique pool addresses"</span><span class="p">)</span>

    <span class="n">str_pos_arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">str_pos</span><span class="p">)</span>
    <span class="n">pool_addresses_arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">pool_addresses</span><span class="p">)</span>

    <span class="n">search_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">TARGET_RANGE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TARGET_RANGE</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">STEP_SIZE</span><span class="p">)</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="n">count_matches_for_offsets</span><span class="p">(</span><span class="n">pool_addresses_arr</span><span class="p">,</span> <span class="n">str_pos_arr</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">search_range</span><span class="p">))</span>
    <span class="n">time_post</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">runtime</span> <span class="o">=</span> <span class="n">time_post</span> <span class="o">-</span> <span class="n">time_pre</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Total runtime: </span><span class="si">{</span><span class="n">runtime</span><span class="p">:.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s">s"</span><span class="p">)</span>

    <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">matches</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">max_offset</span><span class="p">,</span> <span class="n">n_matches</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="n">max_index</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Offset for max alignment: </span><span class="si">{</span><span class="n">max_offset</span><span class="p">:</span><span class="mi">08</span><span class="n">x</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Total matches: </span><span class="si">{</span><span class="n">n_matches</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="n">sns</span><span class="p">.</span><span class="n">set_theme</span><span class="p">()</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">matches</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">matches</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">*</span><span class="n">TARGET_RANGE</span><span class="p">)</span>

    <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Offset'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Aligned strings'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">'plot.png'</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</pre></table></code></div></div><h2 id="base-address-discovery"><span class="mr-2">Base Address Discovery</span><a href="#base-address-discovery" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>When I ran the script with specified hyperparameters against my firmware blob, the code generated the following output:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Found 497 unique strings
Found 1455 unique pool addresses
100%|██████████| 32767/32767 [00:01&lt;00:00, 18749.79it/s]
Total runtime: 2.26s
Offset for max alignment: 00004fe0
Total matches: 317
</pre></table></code></div></div><p>The search took a little over two seconds. The script found 497 unique strings and 1455 unique pool addresses. Using a base address of <code class="language-plaintext highlighter-rouge">0x4fe0</code>, the script was able to match 317 of the strings to corresponding literal pool addresses. However, this information alone does not convey any information about the significance of the maximum that it determined. To give a visual impression of the significance, I show the generated graph below: <img data-src="/assets/images/2021_03_25-result-plot.png" alt="Header Image" data-proofer-ignore></p><p>The figure shows a singular peak at offset <code class="language-plaintext highlighter-rouge">0x4fe0</code>. The peak is very pronounced and represents a significant outlier in comparison to the remaining samples. Hence, it is safe to assume that this value represents the likely load address of the binary.</p><p>To give further weight to the result, I compared the auto analysis results of Ghidra for the default load address <code class="language-plaintext highlighter-rouge">0x0</code> and the result <code class="language-plaintext highlighter-rouge">0x4fe0</code>. The figure below shows the (rotated) <em>Overview</em> sidebar in Ghidra for both analysis attempts. The width of the bar represents the length of the firmware image. The colors encode what data the analysis discovered in the firmware image. Purple indicates code, green indicates data, and red indicates unknown sections.</p><p><img data-src="/assets/images/2021_03_25-ghidra_side_by_side.png" alt="Ghidra Side-by-Side" width="100%" data-proofer-ignore></p><p>The figure shows quite nicely that the second iteration of the analysis with the discovered base address of <code class="language-plaintext highlighter-rouge">0x4fe0</code> lead to a significantly better result. Ghidra was able to discover more instructions across the entire firmware image and more accurately link references to the data section of the image.</p><p>Given the collective results above, <code class="language-plaintext highlighter-rouge">0x4fe0</code> appears to be the correct base address for the firmware image.</p><h2 id="hyperparameter-tuning"><span class="mr-2">Hyperparameter Tuning</span><a href="#hyperparameter-tuning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Lastly, I wanted to check how the selection of the step size would affect the accuracy of the result. Below, I list the result for multiple iterations with varyiing step sizes:</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">Step Size<th style="text-align: right">Runtime<th style="text-align: right">Matches<th style="text-align: right">Base Address<tbody><tr><td style="text-align: left">0x1<td style="text-align: right">28.80s<td style="text-align: right">317<td style="text-align: right"><code class="language-plaintext highlighter-rouge">0x4fe0</code><tr><td style="text-align: left">0x4<td style="text-align: right">7.47s<td style="text-align: right">317<td style="text-align: right"><code class="language-plaintext highlighter-rouge">0x4fe0</code><tr><td style="text-align: left">0x10<td style="text-align: right">2.26s<td style="text-align: right">317<td style="text-align: right"><code class="language-plaintext highlighter-rouge">0x4fe0</code><tr><td style="text-align: left">0x40<td style="text-align: right">1.48s<td style="text-align: right">89<td style="text-align: right"><code class="language-plaintext highlighter-rouge">0x5000</code><tr><td style="text-align: left">0x2000<td style="text-align: right">0.70s<td style="text-align: right">36<td style="text-align: right"><code class="language-plaintext highlighter-rouge">0x4000</code></table></div><p>In our case, decreasing the steps size did not yield any improvement, further demonstrating the correctness of the result. However, increasing the step size past a value of <code class="language-plaintext highlighter-rouge">0x10</code> caused the algorithm to miss the absolute maximum. Nevertheless, the determined maximum remained as close to the actual maximum as possible. This would indicate that it is possible to safe computation time in large searches by iteratively decreasing the target address range along with the step size.</p><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>By using the method proposed in the paper by Zhu et al., I was able to correctly determine the base address of the firmware image I was dealing with. Furthermore, I hope that the code I posted here (and in the <a href="https://gist.github.com/lumagi/28a479c7a41d466660e5a6a76038012c">GitHub Gist</a>) can be of use to someone else.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/firmware/'>firmware</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/arm/" class="post-tag no-text-decoration" >ARM</a> <a href="/tags/firmware/" class="post-tag no-text-decoration" >firmware</a> <a href="/tags/reversing/" class="post-tag no-text-decoration" >reversing</a> <a href="/tags/literal-pool/" class="post-tag no-text-decoration" >literal pool</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Determining ARM firmware base addresses - RAndom Notes on Tech&amp;url=https://lumagi.github.io/posts/finding-arm-firmware-base-with-literal-pools/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Determining ARM firmware base addresses - RAndom Notes on Tech&amp;u=https://lumagi.github.io/posts/finding-arm-firmware-base-with-literal-pools/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://lumagi.github.io/posts/finding-arm-firmware-base-with-literal-pools/&amp;text=Determining ARM firmware base addresses - RAndom Notes on Tech" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/imx6-nand-flash/">Decoding raw i.MX6 NAND flash images</a><li><a href="/posts/Device-ID-support-in-Linux/">PCAN Device ID Support in Linux Kernel</a><li><a href="/posts/finding-arm-firmware-base-with-literal-pools/">Determining ARM firmware base addresses</a><li><a href="/posts/compiling-intree-linux-modules/">Debugging Linux Module Loading with QEMU</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/arm/">ARM</a> <a class="post-tag" href="/tags/bch/">BCH</a> <a class="post-tag" href="/tags/can/">CAN</a> <a class="post-tag" href="/tags/debugging/">Debugging</a> <a class="post-tag" href="/tags/firmware/">firmware</a> <a class="post-tag" href="/tags/flash/">Flash</a> <a class="post-tag" href="/tags/i-mx6/">i.MX6</a> <a class="post-tag" href="/tags/kernel/">Kernel</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/literal-pool/">literal pool</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/imx6-nand-flash/"><div class="card-body"> <em class="timeago small" data-ts="1761499260" > 2025-10-26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Decoding raw i.MX6 NAND flash images</h3><div class="text-muted small"><p> I was recently working with a PCB featuring an i.MX6 SoC and a raw NAND flash chip. The SoC was running a u-boot and an embedded Linux off of the NAND flash chip. Since the debug port was properly ...</p></div></div></a></div><div class="card"> <a href="/posts/Device-ID-support-in-Linux/"><div class="card-body"> <em class="timeago small" data-ts="1692007680" > 2023-08-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PCAN Device ID Support in Linux Kernel</h3><div class="text-muted small"><p> When building a test setup with multiple CAN controllers, it is crucial to ensure persistent device names, no matter boot or enumeration order. The PCAN USB-FD devices by Peak do not export a USB s...</p></div></div></a></div><div class="card"> <a href="/posts/compiling-intree-linux-modules/"><div class="card-body"> <em class="timeago small" data-ts="1639243271" > 2021-12-11 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Debugging Linux Module Loading with QEMU</h3><div class="text-muted small"><p> My company uses the ETAS ES582.1 CAN adapters to interface with a CAN bus. Since recently, the kernel has mainline support for these devices (the etas_es58x driver). However, my work operating sy...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/compiling-intree-linux-modules/" class="btn btn-outline-primary" prompt="Older"><p>Debugging Linux Module Loading with QEMU</p></a> <a href="/posts/Device-ID-support-in-Linux/" class="btn btn-outline-primary" prompt="Newer"><p>PCAN Device ID Support in Linux Kernel</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/lumagi">Lukas Magel</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/arm/">ARM</a> <a class="post-tag" href="/tags/bch/">BCH</a> <a class="post-tag" href="/tags/can/">CAN</a> <a class="post-tag" href="/tags/debugging/">Debugging</a> <a class="post-tag" href="/tags/firmware/">firmware</a> <a class="post-tag" href="/tags/flash/">Flash</a> <a class="post-tag" href="/tags/i-mx6/">i.MX6</a> <a class="post-tag" href="/tags/kernel/">Kernel</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/literal-pool/">literal pool</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
